#!/usr/bin/perl -w
$ID = q$Id$;
#
# faq2html -- Convert some particular text formats into HTML.
#             Copyright 1999 by Russ Allbery <rra@stanford.edu>
#
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.
#
# This program is an ad hoc set of heuristics and tricks, attempting to
# convert a few text file formats that I commonly use into reasonable HTML.
# It's my opinion that general text to HTML conversions is impossible due to
# the huge number of differing formats used by different people when writing
# text; this doesn't try to solve the general problem.  Rather, it's good
# enough to turn the FAQs I maintain into HTML documents, which is all that
# I need of it.

############################################################################
# Modules and declarations
############################################################################

require 5.003;

use strict;
use vars qw($ID %STATE);


############################################################################
# Utility functions
############################################################################

# Removes an initial bullet on a paragraph, replacing it with spaces.
sub debullet { local $_ = shift; s/(\s*)[-*o](\s)/$1 $2/; $_ }

# Removes an initial number on a paragraph, replacing it with spaces.
sub denumber {
    local $_ = shift;
    s/^(\s*)(\d\d?[.\)])(\s)/$1 . ' ' x length ($2) . $3/e;
    $_;
}

# Remove ASCII underlining from a section heading.
sub derule { local $_ = shift; s/^[-=~]+\n//m; $_ }

# Escapes &, <, and > characters found in a string.
sub escape { local $_ = shift; s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g; $_ }

# Returns the length of the indentation of a line or paragraph.
sub indent { $_[0] =~ /^(\s*)/; length $1 }

# Returns the number of lines in a paragraph, not counting trailing blanks.
sub lines { local $_ = shift; s/\s+$/\n/; tr/\n// }

# Remove all whitespace in a string.
sub smash { local $_ = shift; s/\s//g; $_ }

# Undoes HTML character escapes.
sub unescape { local $_ = shift; s/&amp;/&/g; s/&lt;/</g; s/&gt;/>/g; $_ }

# Remove a constant prefix at the beginning of each line of a paragraph.
sub unquote {
    my ($string, $quote) = @_;
    $string =~ s/((?:^|\n)\s*)(\Q$quote\E\s+)/$1 . ' ' x length ($2)/ge;
    $string;
}

# Replace tabs with spaces.
sub untabify {
    local $_ = shift;
    1 while s/^(.*)(\t+)/' ' x (length ($2) * 8 - length ($1) % 8)/me;
    $_;
}

# Given a special-character-escaped URL and some text, wrap <a href></a> to
# that URL around the text.
sub href { '<a href="' . smash (unescape $_[0]) . '">' . $_[1] . '</a>' }

# Looks for a URL in <URL:...> form and wraps a link around it.
sub urlize {
    local $_ = shift;
    s%(&lt;URL:([^.&][^&]+)&gt;)%href ($2, $1)%ge;
    $_;
}

# Remove whitespace at the beginning and end of a string.
sub whitechomp { local $_ = shift; s/^\s+//; s/\s+$//; $_ }


############################################################################
# Identification functions
############################################################################

# Expects a paragraph, returns whether it's in all capital letters.
sub is_allcaps { $_[0] !~ /[^A-Z\s\"\(\),:-]/ }

# Expects a paragraph, returns whether it looks like it's broken into a
# series of short lines.
sub is_broken {
    my $string = shift;
    $string =~ s/\s+$/\n/;
    my @lines = split ("\n", $string);
    my $short = grep { length ($_) < 60 } @lines;
    $short == @lines || $short > 1;
}

# Expects a paragraph, returns whether we're dealing with a bulletted item.
sub is_bullet { $_[0] =~ /^\s*[-*o]\s/ }

# Expects a line, returns whether it's centered (in 74 columns).
sub is_centered {
    $_[0] =~ /^(\s+)(.+)/ && abs (74 - (length $2) - (length $1) * 2) < 2;
}

# Expects a line, returns whether it's a digest divider.
sub is_divider { $_[0] =~ /^-{30}\s*$/ }

# Expects a line, returns whether it's a mail/news header.
sub is_header { $_[0] =~ /^[\w-]+:\s/ }

# Expects a paragraph, returns whether it fits the content of a heading.
sub is_heading { $_[0] =~ /^\s*[ \w\"\(\),:-]+\n(?:[-=~]+\n)?\s*\Z/ }

# Expects a line, returns whether it's an RCS/CVS $\Id$ string.
sub is_id { $_[0] =~ /^\s*\$Id.*\$\s*$/ }

# Expects a paragraph, returns whether it appears to have internal
# whitespace.
sub is_literal { $_[0] =~ /^[ \t]*\S.*(?:[^.?!\"\)\]\n]  |   |\t)\S/m }

# Expects a paragraph, returns undef if it doesn't look like a numbered
# paragraph or the number if it does.
sub is_numbered { ($_[0] =~ /^\s*(\d\d?)[.\)]\s/) ? $1 : undef }

# Expects a paragraph, returns undef if not quoted or the quote character if
# it is quoted.
sub is_quoted { $_[0] =~ /^\s*([^\w\s])\s+.*\n(\s*\1\s+.*\n)*$/ && $1 }

# Expects a line, returns whether it's a rule.
sub is_rule { $_[0] =~ /^\s*[-=]+\s*$/ }

# Expects a line, returns whether it's short (<60 columns).
sub is_short { length $_[0] < 60 }


############################################################################
# HTML constructors
############################################################################

# Wrap a container around data, keeping the tags on the same line.
sub container {
    my ($tag, $data) = @_;
    $data = '<' . $tag . '>' . $data;
    $tag =~ s/ .*//;
    $data =~ s%(\s*)$%</$tag>$1%;
    $data;
}

# Output a list item.  Takes an optional second argument, which if specified
# is the number to use for the item (using the value attribute, which for
# some reason is deprecated under HTML 4.0 without any viable alternative
# for what I use it for).
sub li {
    my ($data, $value) = @_;
    container (defined $value ? "li value=$value" : 'li', $data);
}

# Wrap a container around data, preserving trailing blank lines outside and
# putting the tags on lines of their own.
sub paragraph {
    my ($tag, $data) = @_;
    my $space;
    if ($data =~ s/(\s+)\n$/\n/) {
        $space = $1;
    } else {
        $space = '';
    }
    $data .= "\n" unless ($data =~ /\n$/);
    '<' . $tag . ">\n" . $data . '</' . $tag . ">\n" . $space;
}

# Close any pending open structure elements except the one given and then
# start the given structure element.  If the parameter is undef, just close
# them all.
sub start {
    my $e = shift;
    my $output = '';
    for (qw/blockquote dl ol ul/) {
        if ((!$e || $e ne $_) && $STATE{$_}) {
            undef $STATE{$_};
            $output .= "</$_>\n";
        }
    }
    if (defined $e && !$STATE{$e}) {
        $STATE{$e}++;
        $output .= "<$e>\n";
    }
    $output;
}

# Handle titles, which should have newlines turned into spaces and leading
# and trailing whitespace zapped.
sub title {
    local $_ = shift;
    s/\s*\n\s*/ /g;
    s/^\s+//;
    s/\s+$//;
    '<title>' . $_ . '</title>' . "\n";
}

# Various containers.
sub blockquote { paragraph ('blockquote', @_) }
sub h2         { container ('h2',         @_) }
sub head       { paragraph ('head',       @_) }
sub p          { paragraph ('p',          @_) }


############################################################################
# Main routine
############################################################################

# Trim extraneous garbage from the path.
my $fullpath = $0;
$0 =~ s%.*/%%;

# Figure out what file we're going to be processing.
my ($input, $output) = @ARGV or die "Usage: faq2html infile outfile\n";
open (IN, $input) or die "$0: can't open $input: $!\n";
open (OUT, "> $output") or die "$0: can't write to $output: $!\n";

# Check for a leading RCS/CVS version identifier.  For FAQs that I'm posting
# to Usenet using postfaq, this will always be the first line of the file
# stored on disk.
my $id;
$_ = <IN>;
if (is_id $_) {
    $id = $_;
    $_ = <IN>;
    $_ = <IN> while (defined && /^\s*$/);
}

# Check for mail/news headers.  If we see any, the only ones we care about
# are Subject and From, which we'll use for title information.
my ($author, $title);
while (defined && is_header $_) {
    my ($header, $content) = /^([\w-]+):\s+(.*)/;

    # Deal with continuation lines.
    $_ = <IN>;
    while (defined && /^\s+\S/) { $content .= $_; $_ = <IN> }

    # Save information we care about.
    if    (lc $header eq 'from')    { $author = $content }
    elsif (lc $header eq 'subject') { $title  = $content }
}

# Skip blank lines (either initial ones or ones after headers.
$_ = <IN> while (defined && /^\s*$/);

# Skip over any FAQ subheaders, since currently we're not interested in any
# of that information.  We don't support continuation lines here yet.
$_ = <IN> while (defined && is_header $_);

# Skip over whitespace after subheaders, and also skip over rules.
$_ = <IN> while (defined && (/^\s*$/ || is_rule $_));

# See if we have a centered title at the top of the document.  If so, we'll
# make that the document title unless we also saw a Subject header.  Titles
# shouldn't be in all caps, though.
my $heading;
if (is_centered ($_) && is_heading ($_)) {
    $heading = whitechomp $_;
    if (!$title) {
        $title = $heading;
        $title =~ s/\b([A-Z]+)\b/\L\u$1/g if (is_allcaps $title);
    }
    $_ = <IN>;
    $_ = <IN> while (defined && (/^\s*$/ || is_rule $_));
}

# Generate the heading of the HTML file, using the filename as the title if
# we haven't been able to find a title.
print OUT "<html>\n", head (title ($title || $output));

# Open the body of the document, and print out the heading if we found one.
print OUT "<body>\n";
print OUT "<h1 align=center>$heading</h1>\n\n" if $heading;

# Scan the actual body of the text.  We don't use paragraph mode, since it
# doesn't work with blank lines that contain whitespace; instead, we cobble
# together our own paragraph mode that does.  Note that $_ already has a
# non-blank line of input coming into this loop.
my $line = $_;
while (defined $line) {
    $_ = $line;
    $_ .= $line while (defined ($line = <IN>) && $line =~ /\S/);
    $_ .= $line if defined $line;
    $_ .= $line while (defined ($line = <IN>) && $line =~ /^\s*$/);

    # Everything needs to have special characters escaped.
    $_ = escape $_;

    # We're not dealing with literal text, so untabify it.
    $_ = untabify $_;

    # Check for a heading.  A paragraph is actually a heading if it matches
    # is_heading and either we don't know our indentation or its indentation
    # is the same as or less than the surrounding text.
    my $outdent = !$STATE{indent} || indent ($_) <= $STATE{indent};
    if ($outdent && is_heading ($_)) {
        print OUT start, '<h2>', derule (whitechomp ($_)), "</h2>\n\n";
        undef $STATE{indent};
        next;
    }

    # We're dealing with a normal paragraph of some sort, so go ahead and
    # turn URLs into links.
    $_ = urlize $_;

    # Check for paragraphs quoted with some character and turn them into
    # blockquotes.
    my $quote = is_quoted ($_);
    if ($quote) {
        s/(\s+)\n$/\n/;
        my $space = $1;
        print OUT blockquote (unquote ($_, $quote));
        next;
    }

    # Checked for numbered paragraphs and turn them into lists.
    my $number = is_numbered ($_);
    if (defined $number) {
        $_ = denumber $_;
        $STATE{indent} = indent $_;
        print OUT start ('ol'), li (p ($_), $number);
        next;
    }

    # Looks like a normal paragraph.
    $STATE{indent} = indent $_;
    print OUT start, p ($_);
}

# All done.  Print out our closing tags.
print OUT start, "</body>\n</html>\n";
