#!/usr/bin/perl -w
$ID = q$Id$;
#
# faq2html -- Convert some particular text formats into HTML.
#             Copyright 1999 by Russ Allbery <rra@stanford.edu>
#
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.
#
# This program is an ad hoc set of heuristics and tricks, attempting to
# convert a few text file formats that I commonly use into reasonable HTML.
# It's my opinion that general text to HTML conversions is impossible due to
# the huge number of differing formats used by different people when writing
# text; this doesn't try to solve the general problem.  Rather, it's good
# enough to turn the FAQs I maintain into HTML documents, which is all that
# I need of it.

############################################################################
# Modules and declarations
############################################################################

require 5.003;

use strict;
use vars qw($ID $INDENT @MONTHS %STATE);

# Replace with the month names you want to use, if you don't want English.
@MONTHS = qw(January February March April May June July August September
             October November December);


############################################################################
# Utility functions
############################################################################

# Removes an initial bullet on a paragraph, replacing it with spaces.
sub debullet { local $_ = shift; s/(\s*)[-*o](\s)/$1 $2/; $_ }

# Removes an initial number on a paragraph, replacing it with spaces.
sub denumber {
    local $_ = shift;
    s/^(\s*)(\d\d?[.\)])(\s)/$1 . ' ' x length ($2) . $3/e;
    $_;
}

# Remove ASCII underlining from a section heading.
sub derule { local $_ = shift; s/^[-=~]+\n//m; $_ }

# Escapes &, <, and > characters found in a string.
sub escape { local $_ = shift; s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g; $_ }

# Returns the length of the indentation of a line or paragraph.
sub indent { $_[0] =~ /^(\s*)/; length $1 }

# Returns the number of lines in a paragraph, not counting trailing blanks.
sub lines { local $_ = shift; s/\s+$/\n/; tr/\n// }

# Deal with miniature indents in regular paragraphs.
sub minident {
    local $_ = shift;
    my $space = $INDENT + 2;
    s/\n\s{$space}/<br>\n&nbsp;&nbsp;/;
    $_;
}

# Returns a nicely formatted "Last modified" string from an RCS/CVS Id.
sub modified {
    my $id = shift;
    my ($version, $date) = (split (' ', $id))[2,3];
    my ($year, $month, $day) = split ('/', $date);
    $day =~ s/^0//;
    'Last modified '. $MONTHS[$month - 1] . ' ' . $day . ', ' . $year
        . " (revision $version)";
}

# Read a paragraph in from a file handle, allowing whitespace on the lines
# serving as paragraph dividers but otherwise duplicating paragraph mode.
# It treats the second argument as a buffer, modifying it to hold the unread
# input.
sub slurp {
    my ($fh, $buffer) = @_;
    my ($p, $line);
    $p = $$buffer;
    $p .= $line while (defined ($line = <$fh>) && $line =~ /\S/);
    $p .= $line if defined $line;
    $p .= $line while (defined ($line = <$fh>) && $line =~ /^\s*$/);
    $$buffer = $line;
    $p;
}

# Remove all whitespace in a string.
sub smash { local $_ = shift; s/\s//g; $_ }

# Return the trailing whitespace of a paragraph.
sub trailspace { $_[0] =~ /(\s+)$/; $1 }

# Undoes HTML character escapes.
sub unescape { local $_ = shift; s/&amp;/&/g; s/&lt;/</g; s/&gt;/>/g; $_ }

# Remove a constant prefix at the beginning of each line of a paragraph.
sub unquote {
    my ($string, $quote) = @_;
    $string =~ s/((?:^|\n)\s*)(\Q$quote\E\s+)/$1 . ' ' x length ($2)/ge;
    $string;
}

# Replace tabs with spaces.
sub untabify {
    local $_ = shift;
    1 while s/^(.*)(\t+)/' ' x (length ($2) * 8 - length ($1) % 8)/me;
    $_;
}

# Given a special-character-escaped URL, wrap <a href></a> to that URL
# around it.
sub url {
    my $url = shift;
    my $href = smash (unescape ($url));
    '<a href="' . $href . '">' . $url . '</a>';
}

# Looks for a URL in <URL:...> form and wraps a link around it.
sub urlize {
    local $_ = shift;
    s%&lt;URL:([^.&][^&]+)&gt;%url ($1)%ge;
    $_;
}

# Remove whitespace at the beginning and end of a string.
sub whitechomp { local $_ = shift; s/^\s+//; s/\s+$//; $_ }


############################################################################
# Identification functions
############################################################################

# Expects a paragraph, returns whether it's in all capital letters.
sub is_allcaps { $_[0] !~ /[^A-Z\s\"\(\),:-]/ }

# Expects a paragraph, returns whether it looks like it's broken into a
# series of short lines.
sub is_broken {
    my $string = shift;
    $string =~ s/\s+$/\n/;
    my @lines = split ("\n", $string);
    my $short = grep { length ($_) < 60 } @lines;
    $short >= int (@lines / 2) + 1;
}

# Expects a paragraph, returns whether we're dealing with a bulletted item.
sub is_bullet { $_[0] =~ /^\s*[-*o]\s/ }

# Expects a line, returns whether it's centered (in 74 columns).
sub is_centered {
    $_[0] =~ /^(\s+)(.+)/ && abs (74 - (length $2) - (length $1) * 2) < 2;
}

# Expects a paragraph, returns whether it looks like a title and
# description.
sub is_description {
    $_[0] =~ /^(\s*).*\n(\s+).*\n(?:\2\S.*\n)*/
        && length ($1) < length ($2);
}

# Expects a paragraph, returns whether it's a digest divider.
sub is_divider { $_[0] =~ /^-{30}\s*$/ }

# Expects a line, returns whether it's a mail/news header.
sub is_header { $_[0] =~ /^[\w-]+:\s/ }

# Expects a paragraph, returns whether it fits the content of a heading.
sub is_heading {
    $_[0] =~ /^\s*[ \w\"\(\),:-]+[\w\"\)]\s*\n(?:[-=~]+\s*)?$/;
}

# Expects a line, returns whether it's an RCS/CVS $\Id$ string.
sub is_id { $_[0] =~ /^\s*\$Id.*\$\s*$/ }

# Expects a paragraph, returns whether it appears to have internal
# whitespace.
sub is_literal { $_[0] =~ /^[ \t]*\S.*(?:[^.?!\"\)\]:\n]  |   |\t)\S/m }

# Expects a paragraph, returns undef if it doesn't look like a numbered
# paragraph or the number if it does.
sub is_numbered { ($_[0] =~ /^\s*(\d\d?)[.\)]\s/) ? $1 : undef }

# Expects a paragraph, returns undef if not quoted or the quote character if
# it is quoted.
sub is_quoted { $_[0] =~ /^\s*([^\w\s])\s+.*\n(\s*\1\s+.*\n)*$/ && $1 }

# Expects a paragraph, returns whether it's a rule.
sub is_rule { $_[0] =~ /^\s*[-=]+\s*$/ }

# Expects a paragraph, returns whether it ends with a sentence.  Don't allow
# colons here although we do elsewhere since we use this to decide whether
# to make things <pre> and mjqmail has <pre> lines ending in :.
sub is_sentence { $_[0] =~ /[.?!,;][\)\]\"]?\s*$/ }


############################################################################
# HTML constructors
############################################################################

# Wrap a container around data, keeping the tags on the same line.
sub container {
    my ($tag, $data) = @_;
    $data = '<' . $tag . '>' . $data;
    $tag =~ s/ .*//;
    $data =~ s%(\s*)$%</$tag>$1%;
    $data;
}

# Output a list item.  Takes an optional second argument, which if specified
# is the number to use for the item (using the value attribute, which for
# some reason is deprecated under HTML 4.0 without any viable alternative
# for what I use it for).
sub li {
    my ($data, $value) = @_;
    container (defined $value ? "li value=$value" : 'li', $data);
}

# Wrap a container around data, preserving trailing blank lines outside and
# putting the tags on lines of their own.
sub paragraph {
    my ($tag, $data) = @_;
    my $space;
    if ($data =~ s/(\s+)\n$/\n/) {
        $space = $1;
    } else {
        $space = '';
    }
    $data .= "\n" unless ($data =~ /\n$/);
    '<' . $tag . ">\n" . $data . '</' . $tag . ">\n" . $space;
}

# Close any pending open structure elements except the one given and then
# start the given structure element, followed by the given initial data.  If
# the parameter is undef, just close them all.  I, for purely cosmetic
# reasons in the generated HTML, want the whitespace trailing the last
# paragraph within a structure element to follow the closing tag, so I stash
# that whitespace away in %STATE.
sub start {
    my ($tag, $data) = @_;
    my $e = $tag || '';
    $e =~ s/ .*//;
    $data = '' unless $data;
    my $output = '';
    for (qw/blockquote dd dl li ol ul/) {
        if ((!$e || $e ne $_ || $e eq 'li') && defined $STATE{$_}) {
            if ($e) {
                next if ($e eq 'li' && ($_ eq 'ol' || $_ eq 'ul'));
                next if ($e eq 'ol' && $_ eq 'li');
                next if ($e eq 'ul' && $_ eq 'li');
                next if ($e eq 'dd' && $_ eq 'dl');
                next if ($e eq 'dl' && $_ eq 'dd');
            }
            $output .= "</$_>$STATE{$_}\n";
            delete $STATE{$_};
        }
    }
    if ($e) {
        $output .= $STATE{$e} if defined $STATE{$e};
        if (!$STATE{$e}) {
            $STATE{$e}++;
            $output .= "<$tag>\n";
        }
        if ($data =~ s/(\s+)\n$/\n/) {
            $STATE{$e} = $1;
        } else {
            $STATE{$e} = "\n";
        }
    }
    $output . $data;
}

# Handle titles, which should have newlines turned into spaces and leading
# and trailing whitespace zapped.
sub title {
    local $_ = shift;
    s/\s*\n\s*/ /g;
    s/^\s+//;
    s/\s+$//;
    '<title>' . $_ . '</title>' . "\n";
}

# Various containers.
sub blockquote { paragraph ('blockquote', @_) }
sub dt         { container ('dt',         @_) }
sub h2         { container ('h2',         @_) }
sub head       { paragraph ('head',       @_) }
sub p          { paragraph ('p',          @_) }
sub pre        { container ('pre',        @_) }


############################################################################
# Main routine
############################################################################

# Trim extraneous garbage from the path.
my $fullpath = $0;
$0 =~ s%.*/%%;

# Figure out what file we're going to be processing.
my ($input, $output) = @ARGV or die "Usage: faq2html infile outfile\n";
open (IN, $input) or die "$0: can't open $input: $!\n";
open (OUT, "> $output") or die "$0: can't write to $output: $!\n";

# Check for a leading RCS/CVS version identifier.  For FAQs that I'm posting
# to Usenet using postfaq, this will always be the first line of the file
# stored on disk.
my $id;
$_ = <IN>;
if (is_id $_) {
    $id = $_;
    $_ = <IN>;
    $_ = <IN> while (defined && /^\s*$/);
}

# Check for mail/news headers.  If we see any, the only ones we care about
# are Subject and From, which we'll use for title information.
my ($author, $title);
while (defined && is_header $_) {
    my ($header, $content) = /^([\w-]+):\s+(.*)/;

    # Deal with continuation lines.
    $_ = <IN>;
    while (defined && /^\s+\S/) { $content .= $_; $_ = <IN> }

    # Save information we care about.
    if    (lc $header eq 'from')    { $author = $content }
    elsif (lc $header eq 'subject') { $title  = $content }
}

# Skip blank lines (either initial ones or ones after headers.
$_ = <IN> while (defined && /^\s*$/);

# Skip over any FAQ subheaders, since currently we're not interested in any
# of that information.  We don't support continuation lines here yet.
$_ = <IN> while (defined && is_header $_);

# Skip over whitespace after subheaders, and also skip over rules.
$_ = <IN> while (defined && (/^\s*$/ || is_rule $_));

# See if we have a centered title at the top of the document.  If so, we'll
# make that the document title unless we also saw a Subject header.  Titles
# shouldn't be in all caps, though.
my $heading;
if (is_centered ($_) && is_heading ($_)) {
    $heading = whitechomp $_;
    if (!$title) {
        $title = $heading;
        $title =~ s/\b([A-Z]+)\b/\L\u$1/g if (is_allcaps $title);
    }
    $_ = <IN>;
    $_ = <IN> while (defined && (/^\s*$/ || is_rule $_));
}

# Generate the heading of the HTML file, using the filename as the title if
# we haven't been able to find a title.
print OUT "<html>\n", head (title ($title || $output));

# Open the body of the document, and print out the heading if we found one.
# Otherwise, print out the page title (probably from the Subject header) as
# the main heading if we have a page title.
print OUT "\n<body>\n";
$heading ||= $title;
print OUT "<h1 align=center>$heading</h1>\n" if $heading;

# If we have additional headers, print them out.  Otherwise, If we have
# author information from a From header, print that out under the main
# heading.  If we have RCS/CVS Id information, add another subheading
# containing the version number and the last modified date.  Existing
# subheadings that look like they're just Revision or Date strings are
# replaced by our more nicely formatted string.
if ($heading) {
    my $subheading;
    while (defined && is_centered ($_)) {
        print OUT "<p align=center><strong>\n" unless $subheading;
        $subheading++;
        if ($id && (/\$Revision/ || /\$Date/)) {
            print OUT '  ', modified ($id), "\n";
        } else {
            $_ = escape $_;
            s/\n$/<br>\n/;
            s/^\s+//;
            print OUT '  ', $_;
        }
        $_ = <IN>;
        if (/^\s*$/) {
            print OUT "</strong></p>\n";
            $subheading = 0;
        }
        $_ = <IN> while (defined && (/^\s*$/ || is_rule $_));
    }
    if (!defined $subheading && $author) {
        $subheading++;
        print OUT "<p align=center><strong>\n";
        print OUT '  ', escape ($author), "\n";
        print OUT '  ', modified ($id), "\n" if $id;
    }
    print OUT "</strong></p>\n" if $subheading;
}

# Scan the actual body of the text.  We don't use paragraph mode, since it
# doesn't work with blank lines that contain whitespace; instead, we cobble
# together our own paragraph mode that does.  Note that $_ already has a
# non-blank line of input coming into this loop.
print OUT "\n" if $heading;
my $line = $_;
while (defined $line) {
    $_ = slurp (\*IN, \$line);

    # If we just hit a digest divider, the next thing will likely be a
    # Subject: line that we want to turn into a section header.
    if (is_divider $_) {
        print OUT start, '<hr>', trailspace $_;
        $_ = slurp (\*IN, \$line);
        if (s/^Subject:\s+//) {
            if (/^([\d.]+)[.\)]\s/) {
                print OUT start, h2 (container ("a name=\"$1\"", $_));
            } else {
                print OUT start, h2 ($_);
            }
            undef $INDENT;
            next;
        }
    }

    # Treat lines of dash-type characters as rules.
    if (is_rule $_) { print OUT start, '<hr>', trailspace $_; next }

    # Everything needs to have special characters escaped.
    $_ = escape $_;

    # Check to see if this paragraph looks like literal text.  If so, we
    # wrap it in <pre> and output it as is.
    if (is_literal $_) { print OUT start, pre ($_); next }

    # We're not dealing with literal text, so untabify it.
    $_ = untabify $_;

    # Check for a heading.  A paragraph is actually a heading if it matches
    # is_heading and either we don't know our indentation or its indentation
    # is the same as or less than the surrounding text.
    if ((!defined $INDENT || indent ($_) <= $INDENT) && is_heading ($_)) {
        s/^\s+//;
        if (/^([\d.]+)[.\)]\s/) {
            print OUT start, h2 (container ("a name=\"$1\"", derule ($_)));
        } else {
            print OUT start, h2 (derule ($_));
        }
        undef $INDENT;
        next;
    }

    # We're dealing with a normal paragraph of some sort, so go ahead and
    # turn URLs into links.
    $_ = urlize $_;

    # Check for paragraphs quoted with some character and turn them into
    # blockquotes.
    my $quote = is_quoted ($_);
    if ($quote) {
        print OUT start ('blockquote', p (unquote ($_, $quote)));
        next;
    }

    # Check for numbered paragraphs and turn them into lists.
    my $number = is_numbered ($_);
    if (defined $number) {
        $_ = denumber $_;
        $INDENT = indent $_;
        print OUT start ('ol', start ("li value=$number", p ($_)));
        next;
    }

    # Check for things that look like description lists and handle them.
    if (is_description $_) {
        my $title;
        ($title, $_) = split ("\n", $_, 2);
        $title .= "\n";
        $INDENT = indent $_;
        print OUT start ('dl', dt ($title) . start ('dd', (p ($_))));
        next;
    }

    # A sudden indentation change also means the paragraph should be
    # blockquoted.  Also check to see if it consists of short lines, and if
    # so, add <br> tags.
    if (defined $INDENT && indent ($_) > $INDENT) {
        if (is_broken ($_) || (lines ($_) == 1 && !is_sentence $_)) {
            print OUT start, pre ($_);
        } else {
            print OUT start ('blockquote', p ($_));
        }
        next;
    }

    # Close multiparagraph structure if we've outdented again.
    if ($INDENT && indent ($_) < $INDENT) { print OUT start }

    # Looks like a normal paragraph.
    $INDENT = indent $_;
    print OUT start, p (minident ($_));
}

# All done.  Print out our closing tags.
print OUT start, "</body>\n</html>\n";
