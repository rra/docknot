#!/usr/bin/perl
$ID = q$Id$;
#
# faq2html -- Convert some particular text formats into HTML.
#             Copyright 1999 by Russ Allbery <rra@stanford.edu>
#
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.
#
# This program is an ad hoc set of heuristics and tricks, attempting to
# convert a few text file formats that I commonly use into reasonable HTML.
# It's my opinion that general text to HTML conversions is impossible due to
# the huge number of differing formats used by different people when writing
# text; this doesn't try to solve the general problem.  Rather, it's good
# enough to turn the FAQs I maintain into HTML documents, which is all that
# I need of it.

############################################################################
# Utility functions
############################################################################

# Removes an initial bullet on a paragraph, replacing it with spaces.
sub debullet { local $_ = shift; s/(\s*)[-*o](\s)/$1 $2/; $_ }

# Removes an initial number on a paragraph, replacing it with spaces.
sub denumber {
    local $_ = shift;
    s/^(\s*)(\d\d?[.\)])(\s)/$1 . ' ' x length ($2) . $3/;
    $_;
}

# Escapes &, <, and > characters found in a string.
sub escape { local $_ = shift; s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g; $_ }

# Returns the length of the indentation of a line or paragraph.
sub indent { $_[0] =~ /^(\s*)/; length $1 }

# Returns the number of lines in a paragraph, not counting trailing blanks.
sub lines { local $_ = shift; s/\s+$/\n/; tr/\n// }

# Remove all whitespace in a string.
sub smash { local $_ = shift; s/\s//g; $_ }

# Undoes HTML character escapes.
sub unescape { local $_ = shift; s/&amp;/&/g; s/&lt;/</g; s/&gt;/>/g; $_ }

# Remove a constant prefix at the beginning of each line of a paragraph.
sub unquote {
    my ($string, $quote) = @_;
    $string =~ s/((?:^|\n)\s*)\Q$quote\E\s+/$1/g;
    $string;
}

# Replace tabs with spaces.
sub untabify {
    local $_ = shift;
    1 while s/^(.*)(\t+)/' ' x (length ($2) * 8 - length ($1) % 8)/me;
    $_;
}

# Given a special-character-escaped URL and some text, wrap <a href></a> to
# that URL around the text.
sub href { '<a href="' . smash (unescape $_[0]) . '">' . $_[1] . '</a>' }

# Looks for a URL in <URL:...> form and wraps a link around it.
sub urlize {
    my $string = shift;
    $string =~ s%(&lt;URL:([^.&][^&]+)&gt;)%href ($2, $1)%ge;
    $string;
}


############################################################################
# Identification functions
############################################################################

# Expects a paragraph, returns whether it's in all capital letters.
sub is_allcaps { $_[0] !~ /[^A-Z\"\(\),:-]/ }

# Expects a paragraph, returns whether it looks like it's broken into a
# series of short lines.
sub is_broken {
    my $string = shift;
    $string =~ s/\s+$/\n/;
    my @lines = split ("\n", $string);
    my $short = grep { length ($_) < 60 } @lines;
    $short == @lines || $short > 1;
}

# Expects a paragraph, returns whether we're dealing with a bulletted item.
sub is_bullet { $_[0] =~ /^\s*[-*o]\s/ }

# Expects a line, returns whether it's centered (in 74 columns).
sub is_centered {
    $_[0] =~ /^(\s+)(.+)/ && abs (74 - (length $2) - (length $1) * 2) < 2;
}

# Expects a line, returns whether it's a digest divider.
sub is_divider { $_[0] =~ /^-{30}\s*$/ }

# Expects a line, returns whether it's a mail/news header.
sub is_header { $_[0] =~ /^[\w-]+:\s/ }

# Expects a paragraph, returns whether it fits the content of a heading.
sub is_heading { $_[0] =~ /^\s*[ \w\"\(\),:-]+\n(?:^[-=~]+\n)?\s*\Z/ }

# Expects a line, returns whether it's an RCS/CVS $\Id$ string.
sub is_id { $_[0] =~ /^\s*\$Id.*\$\s*$/ }

# Expects a paragraph, returns whether it appears to have internal
# whitespace.
sub is_literal { $_[0] =~ /^[ \t]*\S.*(?:[^.?!\"\)\]\n]  |   |\t)\S/m }

# Expects a paragraph, returns undef if it doesn't look like a numbered
# paragraph or the number if it does.
sub is_numbered { ($_[0] =~ /^\s*(\d\d?)[.\)]\s/) ? $1 : undef }

# Expects a paragraph, returns undef if not quoted or the quote character if
# it is quoted.
sub is_quoted { $_[0] =~ /^\s*([^\w\s])\s+.*\n(\s*\1\s+.*\n)*$/ && $1 }

# Expects a line, returns whether it's a rule.
sub is_rule { $_[0] =~ /^[-=]{70,80}$/ }

# Expects a line, returns whether it's short (<60 columns).
sub is_short { length $_[0] < 60 }


############################################################################
# HTML constructors
############################################################################

# Wrap a container around data, keeping the tags on the same line.
sub container {
    my ($tag, $data) = @_;
    $data = '<' . $tag . '>' . $data;
    $data =~ s%(\s*)$%</$tag>$1%;
    $data;
}

# Wrap a container around data, preserving trailing blank lines outside and
# putting the tags on lines of their own.
sub paragraph {
    my ($tag, $data) = @_;
    $data =~ s/(\s+)\n$/\n/;
    $data .= "\n" unless ($data =~ /\n$/);
    '<' . $tag . ">\n" . $data . '</' . $tag . ">\n\n" . $1;
}

# Handle titles, which should have newlines turned into spaces and leading
# and trailing whitespace zapped.
sub title {
    local $_ = shift;
    s/\s*\n\s*/ /g;
    s/^\s+//;
    s/\s+$//;
    '<title>' . $_ . '</title>' . "\n";
}

# Various containers.
sub blockquote { paragraph ('blockquote', @_) }
sub head       { paragraph ('head',       @_) }
sub p          { paragraph ('p',          @_) }


############################################################################
# Main routine
############################################################################

# Trim extraneous garbage from the path.
my $fullpath = $0;
$0 =~ s%.*/%%;

# Figure out what file we're going to be processing.
my ($input, $output) = @ARGV or die "Usage: faq2html infile outfile\n";
open (IN, $input) or die "$0: can't open $input: $!\n";
open (OUT, "> $output") or die "$0: can't write to $output: $!\n";

# Check for a leading RCS/CVS version identifier.  For FAQs that I'm posting
# to Usenet using postfaq, this will always be the first line of the file
# stored on disk.
my $id;
$_ = <IN>;
if (is_id $_) {
    $id = $_;
    $_ = <IN>;
    $_ = <IN> while (defined && /^\s*$/);
}

# Check for mail/news headers.  If we see any, the only ones we care about
# are Subject and From, which we'll use for title information.
my ($author, $title);
while (defined && is_header $_) {
    my ($header, $content) = /^([\w-]+):\s+(.*)/;

    # Deal with continuation lines.
    $_ = <IN>;
    while (defined && /^\s+\S/) { $content .= $_; $_ = <IN> }

    # Save information we care about.
    if    (lc $header eq 'from')    { $author = $content }
    elsif (lc $header eq 'subject') { $title  = $content }
}

# Skip blank lines (either initial ones or ones after headers.
$_ = <IN> while (defined && /^\s*$/);

# Skip over any FAQ subheaders, since currently we're not interested in any
# of that information.  We don't support continuation lines here yet.
$_ = <IN> while (defined && is_header $_);
$_ = <IN> while (defined && /^\s*$/);

# Generate the heading of the HTML file, using the filename as the title if
# we haven't been able to find a title.
print OUT "<html>\n", head (title ($title || $output));

# Scan the actual body of the text.  We don't use paragraph mode, since it
# doesn't work with blank lines that contain whitespace; instead, we cobble
# together our own paragraph mode that does.  Note that $_ already has a
# non-blank line of input coming into this loop.
print OUT "<body>\n";
while (defined) {
    my $line;
    $_ .= $line while (defined ($line = <IN>) && $line =~ /\S/);
    $_ .= $line;
    $_ .= $line while (defined ($line = <IN>) && $line =~ /^\s*$/);
    $_ = urlize (untabify (escape ($_)));
    my $quote = is_quoted ($_);
    if ($quote) {
        s/(\s+)\n$/\n/;
        my $space = $1;
        print OUT blockquote (unquote ($_, $quote));
    } else {
        print OUT p ($_);
    }
    $_ = $line;
}
print OUT "</body>\n</html>\n";
