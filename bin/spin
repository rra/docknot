#!/usr/bin/perl -w
$ID = q$Id$;
#
# spin -- Translate thread (an HTML macro language) into HTML.
#         Copyright 1999, 2000, 2001, 2002 by Russ Allbery <rra@stanford.edu>
#
# This program is free software; you may redistribute it and/or modify it
# under the same terms as Perl itself.

##############################################################################
# Modules and declarations
##############################################################################

require 5.005;

use strict;
use subs qw(expand parse);
use vars qw($DOCID $FILE $FULLPATH $ID $OUTPUT $SOURCE $SPACE $SPINID @STATE
            $STYLES %commands %macros %strings);

use Getopt::Long qw(GetOptions);
use Image::Size qw(html_imgsize);
use File::Copy qw(copy);
use File::Find qw(find);
use POSIX qw(strftime);
use Text::Balanced qw(extract_bracketed);

##############################################################################
# Output
##############################################################################

# Sends something to the output file.  Pull out any trailing space and stash
# it temporarily, and put any trailing space that we'd previously stashed into
# the output string after any close tags.  This gets spacing working properly
# around boundaries.
sub output {
    my $output = join ('', @_);
    if ($SPACE) {
        $output =~ s%^(\s*(?:</(?!body)[^>]+>\s*)*)%$1$SPACE%;
        $SPACE = '';
    }
    if ($output =~ s/\n(\s+)\z/\n/) { $SPACE = $1 }
    print OUT $output;
}

##############################################################################
# Basic parsing
##############################################################################

# Escapes &, <, and > characters found in a string.
sub escape { local $_ = shift; s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g; $_ }

# Wrap something in paragraph markers, being careful to get newlines right.
# Special-case a paragraph consisting entirely of <span> by turning it into a
# <p> with the same class.
sub paragraph {
    my $text = shift;
    $text =~ s/^\n(\s*\n)*//;
    $text =~ s/(\S[ \t]*)\z/$1\n/;
    if ($text =~ m%^(\s*)<span(?!.*<span)([^>]*)>(.*)</span>(\s*)\z%s) {
        my ($lead, $class, $text, $trail) = ($1, $2, $3, $4);
        return "$lead<p$class>$text</p>$trail";
    } else {
        $text =~ s/^/<p>\n/;
        $text =~ s%(\n\s*)\z%\n</p>$1%;
        return $text;
    }
}

# Opens or closes a border of a continued structure.  Either takes the name of
# the state and its start and end tags, or takes no arguments to close all
# open states.
sub border {
    my ($border, $start, $end) = @_;
    my $output = '';
    if ($border) {
        if (!@STATE || $STATE[0][0] ne $border) {
            $output .= $start;
            unshift (@STATE, [ $border, $end ]);
        }
    } else {
        for (@STATE) { $output .= $$_[1] }
        undef @STATE;
    }
    return $output;
}

# Extract some number of arguments from the front of the given string.  If the
# optional third argument is true, try to pull off a parenthesized formatting
# instruction first, returning it as the first result (or undef if it's not
# found).
sub extract {
    my ($text, $count, $format) = @_;
    my (@result, $code);
    $text =~ s/\s*//;
    if ($format && $text =~ /^\(/) {
        ($result[0], $text) = extract_bracketed ($text, '()');
        $result[0] = substr ($result[0], 1, -1);
    } else {
        $result[0] = '';
    }
    for (1..$count) {
        ($result[$_], $text) = extract_bracketed ($text, '[]');
        if ($result[$_]) {
            $result[$_] = substr ($result[$_], 1, -1);
        } else {
            warn "$0:$FILE:$.: Can't find argument $_\n";
        }
    }
    unless ($format) { shift @result }
    (@result, $text);
}

# Process a macro.  Takes the number of arguments, the definition of the
# macro, a flag saying whether we're at a block level, and then the values of
# all the arguments.  Only straight substitution commands are allowed here, of
# course.
sub macro {
    my ($args, $definition, $block) = @_;
    $definition =~ s/\\(\d+)/($1 > $args) ? "\\$1" : $_[$1 + 2]/ge;
    parse ($definition, $block);
}

# Expand a given command into its representation.  This function is mutually
# recursive with parse.  Takes a third argument indicating whether this is a
# top-level element (if it is, and it doesn't generate its own container, it
# may have to be wrapped in <p>) and a fourth argument saying whether we're at
# the top level of the document.
sub expand {
    my ($command, $text, $block, $top) = @_;
    if ($command eq '==') {
        my ($new, $args, $definition);
        ($new, $args, $definition, $text) = extract ($text, 3);
        $macros{$new} = [ $args, $definition ];
        return ('', $text);
    } elsif ($command eq '=') {
        my ($variable, $value);
        ($variable, $value, $text) = extract ($text, 2);
        $strings{$variable} = parse ($value);
        return ('', $text);
    } elsif ($command =~ s/^=//) {
        if (exists $strings{$command}) {
            return ($strings{$command}, $text);
        } else {
            warn "$0:$FILE:$.: unknown string $command\n";
            return ('', $text);
        }
    } elsif ($command eq '\\') {
        return ('\\', $text);
    } elsif (ref $macros{$command}) {
        my ($args, $definition) = @{ $macros{$command} };
        my @args;
        if ($args > 0) {
            @args = extract ($text, $args, 0);
            $text = pop @args;
        }
        my $block = $block && ($text !~ /\S/);
        return (macro ($args, $definition, $block, @args), $text);
    } else {
        if (!ref $commands{$command}) {
            warn "$0:$FILE:$.: bad command $command\n";
            return ('', $text);
        }
        my ($args, $handler) = @{ $commands{$command} };
        my ($blocktag, $result);
        if ($args == 0) {
            ($blocktag, $result) = &$handler ();
        } else {
            my @args = extract ($text, $args, 1);
            $text = pop @args;
            my $format = shift @args;
            ($blocktag, $result) = &$handler ($format, @args);
        }
        if ($block && !$blocktag && $text !~ /\S/) {
            $result = paragraph ($result . $text);
            $result = border . $result if $top;
            return ($result, '');
        } else {
            return ($result, $text);
        }
    }
}

# Given a text string, check it for escape sequences.  If there are any,
# expand them, returning the final string after all expansions have been done.
# This function is mutually recursive with expand.  Takes two flags, one to
# say whether we're at the block level, and one to say whether we're at the
# top of the file.
sub parse {
    my ($text, $block, $top) = @_;
    if (index ($text, '\\') == -1) {
        if ($top) {
            return border . paragraph ($text);
        } elsif ($block) {
            return paragraph ($text);
        } else {
            return $text;
        }
    }

    # Chop off everything up to the first backslash and save it in output.
    # Then grab the escape and figure out what to do with it.
    my $output = '';
    my $complex = 0;
    while ($text) {
        $text =~ s/^([^\\]+|\\([\w=]+|.))?//
            or die "$0:$FILE:$.: unable to parse at '"
                . substr ($text, 0, 20) . "'";
        my $command;
        if (index ($1, '\\') == -1) {
            $output .= $1;
            $complex = 1;
        } else {
            $command = $2;
            my $result;
            my $block = $block && ($output !~ /\S/);
            ($result, $text) = expand ($command, $text, $block, $top);
            $output .= $result;
        }
        if ($text =~ s/^\n(\s*)//) {
            $output .= "\n" if ($text || $complex);
            $output .= $1;
        }
    }
    $output = paragraph ($output) if $block && $complex;
    $output = border . $output if $top && $complex;
    return $output;
}

##############################################################################
# Page placement
##############################################################################

# Given the name of the current file being processed, opens a .placement file
# if available and returns the navigation links for that file.  If no
# .placement file is present, nothing is returned.
sub placement {
    my $file = shift;

    # Grab placement information for links if we have it.
    my $output = '';
    if (open (PLACEMENT, '.placement')) {
        local $_;
        local $/ = "\n";
        my (%titles, @placement);
        while (<PLACEMENT>) {
            next if /^\s*$/;
            last if /---/;
            my ($page, $title) = split (' ', $_, 2);
            chomp $title;
            $titles{$page} = $title;
        }
        while (<PLACEMENT>) {
            if (/^$file\s/) {
                chomp;
                @placement = split;
                shift @placement;
                last;
            }
        }
        close PLACEMENT;
        unless (@placement) {
            die "$0: can't find placement for $file\n";
        }
        @placement = map { $_ eq '!' ? undef : $_ } @placement;
        unless ($placement[0] || $placement[1] || $placement[2]) {
            return;
        }

        my @text = ('Onward to', 'Back to', 'Return to');
        my $br = '';
        $output .= qq(<p class="navigation">\n);
        for my $i (0..2) {
            next unless defined $placement[$i];
            my $href = '<a href="' . $placement[$i] . '">' .
                $titles{$placement[$i]} . '</a>';
            $href =~ s/^(<[^>]+>)the /the $1/;
            $output .= $br . '    ' . $text[$i] . ' ' . $href;
            $br = "<br />\n";
        }
        $output .= "\n</p>\n\n";
    }
    return $output;
}

# Return the signature file for pages in this directory, if present.
sub sign {
    my $output = '';
    if (open (SIG, '< .signature')) {
        local $/ = "\n";
        my @signature = <SIG>;
        chomp @signature;
        close SIG;
        $output .= join ("\n    ", @signature);
        $output .= " <br />\n    ";
    }
    return $output;
}

##############################################################################
# Supporting functions
##############################################################################

# Given the format argument to a command, return the class or id attribute
# that should be used preceeded by a space, or an empty string if none should
# be used.
sub format_string {
    my $format = shift;
    if ($format) {
        if ($format =~ s/^\#//) {
            return ' id="' . $format . '"';
        } else {
            return ' class="' . $format . '"';
        }
    } else {
        return '';
    }
}

# Splits a block of text apart at paired newlines so that it can be reparsed
# in paragraphs, but combines a paragraph with the next one if it has an
# unbalanced number of open brackets.  Used by containiners like \block that
# can contain multiple paragraphs.
sub split_paragraphs {
    my $text = shift;
    my @paragraphs;
    while ($text && $text =~ s/^(.*?(?:\n\n+|\s*\z))//s) {
        my $paragraph = $1;
        my $open = ($paragraph =~ tr/\[//);
        my $close = ($paragraph =~ tr/\]//);
        while ($text && $open > $close) {
            $text =~ s/^(.*?(?:\n\n+|\s*\z))//s;
            my $extra = $1;
            $open += ($extra =~ tr/\[//);
            $close += ($extra =~ tr/\]//);
            $paragraph .= $extra;
        }
        push (@paragraphs, $paragraph);
    }
    return @paragraphs;
}

# A simple block element.  Takes the name of the tag, an initial string to be
# prepended verbatim, the format, and the text.  Handles splitting the
# argument on paragraph boundaries and surrounding things properly with the
# tag.
sub block {
    my ($tag, $border, $format, $text) = @_;
    my $output;
    if ($format eq 'packed') {
        $output = parse ($text, 0);
    } else {
        $output = join ('', map { parse ($_, 1) } split_paragraphs ($text));
    }
    $output = $border . "<$tag" . format_string ($format) . '>' . $output;
    $output =~ s%\s*\z%</$tag>\n%;
    return (1, $output);
}

# A heading.  Handles formats of #something specially by adding an <a name>
# tag inside the heading tag to make it a valid target for internal links even
# in old browsers.
sub heading {
    my ($level, $format, $text) = @_;
    my $output = border;
    if ($format && $format =~ /^\#/) {
        my $tag = $format;
        $tag =~ s/^\#//;
        $text = qq(<a name="$tag">$text</a>);
    }
    $output .= "<h$level" . format_string ($format) . '>';
    $output .= parse ($text);
    $output =~ s/\n\z//;
    $output .= "</h$level>\n";
    return (1, $output);
}

# A simple inline element.  Takes the name of the tag, the format, and the
# body and returns the appropriate list of block level and HTML.
sub inline {
    my ($tag, $format, $text) = @_;
    my $output = "<$tag" . format_string ($format) . '>';
    $output .= parse ($text) . "</$tag>";
    return (0, $output);
}

##############################################################################
# Commands
##############################################################################

# Basic inline commands.
sub do_break  { (0, '<br />') }
sub do_cite   { inline ('cite', @_) }
sub do_class  { inline ('span', @_) }
sub do_code   { inline ('code', @_) }
sub do_bold   { inline ('strong', @_) }
sub do_emph   { inline ('em', @_) }
sub do_italic { inline ('i', @_) }
sub do_rule   { return (1, border . "<hr />\n") }

# Basic block commands.
sub do_block  { block ('blockquote', '', @_) }
sub do_bullet { block ('li', border ('bullet', "<ul>\n", "</ul>\n"), @_) }
sub do_number { block ('li', border ('number', "<ol>\n", "</ol>\n"), @_) }

# A description list entry, which takes the heading and the body as arguments.
sub do_desc {
    my ($format, $heading, $text) = @_;
    my $initial = border ('desc', "<dl>\n", "</dl>\n");
    $initial .= '<dt>' . parse ($heading) . "</dt>\n";
    return block ('dd', $initial, $format, $text);
}

# An HTML entity.  Check for and handle numeric entities properly.
sub do_entity {
    my ($format, $char) = @_;
    $char = parse ($char);
    if ($char =~ /^\d+$/) {
        return (0, '&#' . $char . ';');
    } else {
        return (0, '&' . $char . ';');
    }
}

# Generates the page heading at the top of the document.  Takes as arguments
# the page title and the page style.  This is where the XHTML declarations
# come from.
sub do_heading {
    my ($format, $title, $style) = @_;
    my $output = qq(<?xml version="1.0" encoding="iso-8859-1"?>\n);
    $output .= qq(<!DOCTYPE html\n);
    $output .= qq(    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"\n);
    $output .= qq(    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">\n);
    $output .= qq(\n<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en");
    $output .= qq( lang="en">\n);
    $output .= qq(<head>\n  <title>$title</title>\n);
    $output .= qq(  <meta http-equiv="Content-Type");
    $output .= qq( content="text/html; charset=iso-8859-1" />\n);
    if ($style) {
        $style .= '.css';
        $style = $STYLES . $style if $STYLES;
        $output .= qq(  <link rel="stylesheet" href="$style");
        $output .= qq( type="text/css" />\n);
    }
    $output .= "</head>\n\n<!-- $SPINID -->\n";
    $output .= "<!-- $DOCID -->\n" if $DOCID;
    $output .= "\n<body>\n";
    return (1, $output);
}

# Used to save the RCS Id for the document.  Doesn't actually output anything
# (the identifier is later used in do_heading).
sub do_id {
    my ($format, $id) = @_;
    $DOCID = $id;
    return (1, '');
}

# Include an image.  The size is added to the HTML tag automatically.  Takes
# the relative path to the image and the alt text.
sub do_image {
    my ($format, $image, $text) = @_;
    $image = parse ($image);
    $text = parse ($text);
    my $size = lc html_imgsize ($image);
    my $output = qq(<img src="$image" alt="$text" $size);
    $output .= format_string ($format) . " />\n";
    return (1, $output);
}

# A link to a URL or partial URL.
sub do_link {
    my ($format, $url, $text) = @_;
    my $output = '<a href="' . parse ($url) . '"';
    $output .= format_string ($format) . '>' . parse ($text) . '</a>';
    return (0, $output);
}

# Preformatted text, the same as the HTML tag.
sub do_pre {
    my ($format, $text) = @_;
    my $output = '<pre' . format_string ($format) . '>';
    $output .= parse ($text) . "</pre>\n";
    return (1, $output);
}

# Used for the leading quotes that I have on many of my pages.  Takes the
# quote, the author, and the citation; the citation may be empty.  If the
# format is "broken", adds line breaks at the end of each line.
sub do_quote {
    my ($format, $quote, $author, $cite) = @_;
    my $output = border . '<blockquote class="quote">';
    $quote = join ('', map { parse ($_, 1) } split_paragraphs ($quote));
    if ($format && $format eq 'broken') {
        $quote =~ s%(\S *)(\n\s*(?!</p>)\S)%$1<br />$2%g;
        $quote =~ s%\n<br />%\n%g;
        $quote =~ s%<p><br />%<p>%g;
    }
    $quote =~ s/\n+$//;
    if ($format) {
        my $class = format_string ($format);
        $quote =~ s/<p>/<p$class>/g;
    }
    $output .= $quote;
    if ($author) {
        $author = parse ($author);
        $output .= qq(<p class="attribution">\n);
        if ($cite) {
            $cite = parse ($cite);
            $output .= "    $author,\n    $cite\n";
        } else {
            $output .= "    $author\n";
        }
        $output .= "</p>";
    } else {
        $output .= "\n";
    }
    $output .= "</blockquote>\n";
    return (1, $output);
}

# Used to end each page, this adds the navigation links and my standard
# address block.
sub do_signature {
    my $output = border;
    if ($FILE eq '-') {
        $output .= "</body>\n</html>\n";
        return (1, $output);
    }
    my $file = $FILE;
    $file =~ s/\.th$/.html/;
    $output .= placement $file;

    # Figure out the modified dates and print out the rest of the footer.
    my $modified = (split (' ', $DOCID))[3];
    if ($modified) {
        $modified =~ s{^(\d+)/(\d+)/(\d+)}{
            sprintf ("%d-%02d-%02d", $1, $2, $3)
        }e;
    } else {
        $modified = strftime ('%Y-%m-%d', gmtime ((stat $FILE)[9]));
    }
    my $spun = strftime ('%Y-%m-%d', gmtime);
    my $ref = '<a href="http://www.eyrie.org/~eagle/software/web/">spun</a>';
    if ($modified eq $spun) {
        $modified = "Last modified and\n    $ref $modified";
    } else {
        $modified = "Last $ref\n    $spun from thread modified $modified";
    }
    $output .= "<address>\n    " . sign;
    $output .= "$modified\n</address>\n</body>\n</html>\n";
    return (1, $output);
}

# The table of available commands.  First column is the number of arguments,
# second column is the handler, and the third column is whether this is its
# own top-level element or whether it needs to be wrapped in <p> tags.
%commands = (block      => [ 1, \&do_block      ],
             break      => [ 0, \&do_break      ],
             bullet     => [ 1, \&do_bullet     ],
             class      => [ 1, \&do_class      ],
             cite       => [ 1, \&do_cite       ],
             code       => [ 1, \&do_code       ],
             bold       => [ 1, \&do_bold       ],
             desc       => [ 2, \&do_desc       ],
             emph       => [ 1, \&do_emph       ],
             entity     => [ 1, \&do_entity     ],
             heading    => [ 2, \&do_heading    ],
             id         => [ 1, \&do_id         ],
             image      => [ 2, \&do_image      ],
             italic     => [ 1, \&do_italic     ],
             link       => [ 2, \&do_link       ],
             number     => [ 1, \&do_number     ],
             pre        => [ 1, \&do_pre        ],
             quote      => [ 3, \&do_quote      ],
             rule       => [ 0, \&do_rule       ],
             signature  => [ 0, \&do_signature  ]);

# Add handlers for all the headings.
for (1..6) { $commands{"h$_"} = [ 1, eval "sub { heading ($_, \@_) }" ] }

##############################################################################
# Interface
##############################################################################

# This function is called, giving an input and an output file name, to spin
# HTML from thread.
sub spin {
    my ($thread, $output) = @_;
    $FILE = $thread;
    open (IN, $thread) or die "$0: can't open $thread: $!\n";
    open (OUT, "> $output") or die "$0: can't create $output: $!\n";
    $SPACE = '';

    # Set up our initial comment.
    my $version = (split (' ', $ID))[2];
    my $date = strftime ('%Y-%m-%d %T -0000', gmtime);
    $SPINID = "Spun from " . ($thread eq '-' ? 'stdin' : $thread)
        . " by spin $version on $date";

    # Parse the thread file a paragraph at a time (but pick up macro contents
    # that are continued across paragraphs.
    local $/ = '';
    local $_;
    while (<IN>) {
        my $open = tr/\[//;
        my $close = tr/\]//;
        while (!eof && $open > $close) {
            my $extra = <IN>;
            $open += ($extra =~ tr/\[//);
            $close += ($extra =~ tr/\]//);
            $_ .= $extra;
        }
        my $result = parse (escape ($_), 1, 1);
        output $result unless ($result =~ /^\s*$/);
    }
    print OUT $SPACE;
    close IN;
    close OUT;
}

##############################################################################
# Per-file operations
##############################################################################

# A wrapper around the cl2xhtml script, used to handle .changelog pointers in
# a tree being spun.  Adds the navigation links and the signature to the
# cl2xhtml output.
sub cl2xhtml {
    my ($source, $output, $name) = @_;
    my $style = $STYLES . 'changelog.css';
    my @page = `cl2xhtml -n $name -s $style $source`;
    open (OUT, "> $output") or die "$0: can't create $output: $!\n";

    # Grab the first few lines of input, looking for a blurb.  Give up if we
    # encounter <html> first.
    my $blurb;
    local $_;
    while (defined ($_ = shift @page)) {
        last if /<html>/i;
        if (/<!--\s*(Generated.*?)\s*-->/) {
            $blurb = $1;
            $blurb =~ s/ \d\d:\d\d:\d\d -0000//;
            $blurb =~ s/ \(\d{4}-\d\d-\d\d\)//;
            last;
        }
        print OUT $_;
    }
    print OUT $_;

    # Snarf input and write it to output until we see </body>, which is our
    # signal to start adding things.  We just got very confused if </body> was
    # on the same line as <html>, so don't do that.
    print OUT $_ while (defined ($_ = shift @page) && !m%</body>%i);

    # Print out our separator line and placement information, if any.
    my $file = $output;
    $file =~ s%^.*/%%;
    output placement $file;

    # Print out the signature and blurb.
    $blurb =~ s(cl2xhtml)
        (\n<a href="http://www.eyrie.org/~eagle/software/web/">cl2xhtml</a>);
    output "<address>\n    ";
    output sign;
    output "$blurb\n</address>\n\n";

    # Finish with the cl2xhtml output.
    print OUT $SPACE, $_, @page;
}

# A wrapper around the cvs2xhtml script, used to handle .log pointers in a
# tree being spun.  Adds the navigation links and the signature to the
# cvs2xhtml output.
sub cvs2xhtml {
    my ($source, $output) = @_;
    my $dir = $source;
    $dir =~ s%/+[^/]+$%%;
    my $name = $source;
    $name =~ s%^.*/%%;
    my $style = $STYLES . 'cvs.css';
    my @page = `(cd $dir && cvs log $source) | cvs2xhtml -n $name -s $style`;
    open (OUT, "> $output") or die "$0: can't create $output: $!\n";

    # Grab the first few lines of input, looking for a blurb.  Give up if we
    # encounter <html> first.
    my $blurb;
    local $_;
    while (defined ($_ = shift @page)) {
        last if /<html>/i;
        if (/<!--\s*(Generated.*?)\s*-->/) {
            $blurb = $1;
            $blurb =~ s/ \d\d:\d\d:\d\d -0000//;
            $blurb =~ s/ \(\d{4}-\d\d-\d\d\)//;
            last;
        }
        print OUT $_;
    }
    print OUT $_;

    # Snarf input and write it to output until we see </body>, which is our
    # signal to start adding things.  We just got very confused if </body> was
    # on the same line as <html>, so don't do that.
    print OUT $_ while (defined ($_ = shift @page) && !m%</body>%i);

    # Print out our separator line and placement information, if any.
    my $file = $output;
    $file =~ s%^.*/%%;
    output placement $file;

    # Print out the signature and blurb.
    $blurb =~ s(cvs2xhtml)
        (\n<a href="http://www.eyrie.org/~eagle/software/web/">cvs2xhtml</a>);
    output "<address>\n    ";
    output sign;
    output "$blurb\n</address>\n\n";

    # Finish with the cvs2xhtml output.
    print OUT $SPACE, $_, @page;
}

# A wrapper around the faq2html script, used to handle .faq pointers in a tree
# being spun.  Adds the navigation links and the signature to the faq2html
# output.
sub faq2html {
    my ($source, $output, $style) = @_;
    if (!$style) {
        $style = $STYLES . 'faq.css';
    }
    my @page = `faq2html -s '$style' $source`;
    open (OUT, "> $output") or die "$0: can't create $output: $!\n";

    # Grab the first few lines of input, looking for a blurb.  Give up if we
    # encounter <html> first.
    my $blurb;
    local $_;
    while (defined ($_ = shift @page)) {
        last if /<html>/i;
        if (/<!--\s*(Converted.*)\s*-->/) { $blurb = $1; last }
        print OUT $_;
    }
    print OUT $_;

    # Snarf input and write it to output until we see </body>, which is our
    # signal to start adding things.  We just got very confused if </body> was
    # on the same line as <html>, so don't do that.
    print OUT $_ while (defined ($_ = shift @page) && !m%</body>%i);

    # Print out our separator line and placement information, if any.
    my $file = $output;
    $file =~ s%^.*/%%;
    output placement $file;

    # Print out the signature and blurb.
    $blurb =~ s(faq2html)
        (\n<a href="http://www.eyrie.org/~eagle/software/web/">faq2html</a>);
    output "<address>\n    ";
    output sign;
    output "$blurb\n</address>\n\n";

    # Finish with the faq2html output.
    print OUT $SPACE, $_, @page;
}

# A wrapper around pod2thread and spin -f, used to handle .pod pointers in a
# tree being spun.  Adds the navigation links and the signature to the output.
sub pod2html {
    my ($source, $output, $options) = @_;
    $options = '-n' unless $options;
    my $style = ($STYLES ? " -s $STYLES" : '');
    my @page = `pod2thread -s pod $options $source | $FULLPATH -f$style`;
    open (OUT, "> $output") or die "$0: can't create $output: $!\n";

    # Grab the first few lines of input, looking for a blurb.  Give up if we
    # encounter <html> first.
    my $blurb = '';
    my $docid = '';
    local $_;
    while (defined ($_ = shift @page)) {
        last if /<html/i;
        if (/<!--\s*(Spun from stdin.*?)\s*-->/) { $blurb = $1 }
        if (/<!--\s*(\$Id.*?)\s*-->/) { $docid = $1 }
        print OUT $_;
    }
    print OUT $_ if defined;

    # Snarf input and write it to output until we see </body>, which is our
    # signal to start adding things.  We just got very confused if </body> was
    # on the same line as <html>, so don't do that.
    print OUT $_ while (defined ($_ = shift @page) && !m%</body>%i);

    # Print out our separator line and placement information, if any.
    my $file = $output;
    $file =~ s%^.*/%%;
    output placement $file;

    # Print out the signature and blurb.
    output "<address>\n    ";
    output sign;
    my $modified = (split (' ', $docid))[3];
    if ($modified) {
        $modified =~ s{^(\d+)/(\d+)/(\d+)}{
            sprintf ("%d-%02d-%02d", $1, $2, $3)
        }e;
    } else {
        $modified = strftime ('%Y-%m-%d', gmtime ((stat $source)[9]));
    }
    my $spun = (split (' ', $blurb))[7];
    unless ($spun) { $spun = strftime ('%Y-%m-%d', gmtime) }
    my $ref = '<a href="http://www.eyrie.org/~eagle/software/web/">spun</a>';
    if ($modified eq $spun) {
        $blurb = "Last modified and\n$ref $modified";
    } else {
        $blurb = "Last\n$ref $spun\nfrom POD modified $modified";
    }
    output "$blurb\n</address>\n\n";

    # Finish with the faq2html output.
    print OUT $SPACE, $_, @page;
}

# This routine is called for every file in the source tree, and references the
# variables $SOURCE and $OUTPUT to find the roots of the source and output
# tree.  It decides what to do with each file, whether spinning it or copying
# it.  It's called from within File::Find and therefore uses the standard
# File::Find variables.
sub process_file {
    return if /^\./;
    $File::Find::prune = 1, return if $_ eq 'CVS';
    my $input = $File::Find::name;
    my $output = $input;
    $output =~ s/^\Q$SOURCE/$OUTPUT/ or die "$0: $input out of tree?\n";
    my $shortout = $output;
    $shortout =~ s/^\Q$OUTPUT/.../;
    if (-d && -d $output) {
        return;
    } elsif (-d && !-d $output) {
        if (-e $output) {
            die "$0: can't replace $output with a directory\n";
        } else {
            mkdir ($output, 0755) or die "$0: mkdir $output failed: $!\n";
        }
    } elsif (/.changelog$/) {
        $output =~ s/\.changelog$/.html/;
        $shortout =~ s/\.changelog$/.html/;
        open (POINTER, $input) or die "$0: can't open $input: $!\n";
        my $file = <POINTER>;
        my $name = <POINTER>;
        close POINTER;
        chomp $file;
        chomp $name;
        return if (-e $output && -M $file >= -M $output);
        print "Formatting log for $shortout\n";
        cl2xhtml ($file, $output, $name);
    } elsif (/.faq$/) {
        $output =~ s/\.faq$/.html/;
        $shortout =~ s/\.faq$/.html/;
        open (POINTER, $input) or die "$0: can't open $input: $!\n";
        my $master = <POINTER>;
        my $style = <POINTER>;
        chomp $style if $style;
        close POINTER;
        if ($style && $style !~ /\./) {
            $style .= '.css';
        }
        if ($style && $style !~ m%/%) {
            $style = $STYLES . $style;
        }
        chomp $master;
        return if (-e $output && -M $master >= -M $output);
        print "Formatting $shortout\n";
        faq2html ($master, $output, $style);
    } elsif (/\.log$/) {
        $output =~ s/\.log$/.html/;
        $shortout =~ s/\.log$/.html/;
        open (POINTER, $input) or die "$0: can't open $input: $!\n";
        my $file = <POINTER>;
        close POINTER;
        chomp $file;
        return if (-e $output && -M $file >= -M $output);
        print "Generating log for $shortout\n";
        cvs2xhtml ($file, $output);
    } elsif (/\.rpod$/) {
        $output =~ s/\.rpod$/.html/;
        $shortout =~ s/\.rpod$/.html/;
        open (POINTER, $input) or die "$0: can't open $input: $!\n";
        my $file = <POINTER>;
        my $options = <POINTER>;
        close POINTER;
        chomp $file;
        chomp $options if $options;
        return if (-e $output && -M $file >= -M $output);
        print "Formatting $shortout\n";
        pod2html ($file, $output, $options);
    } elsif (/\.th$/) {
        $output =~ s/\.th$/.html/;
        $shortout =~ s/\.th$/.html/;
        return if (-e $output && -M $_ >= -M $output);
        print "Spinning $shortout\n";
        spin ($_, $output);
    } elsif (!-e $output || -M $_ < -M $output) {
        print "Updating $shortout\n";
        copy ($_, $output)
            or die "$0: copy of $input to $output failed: $!\n";
    }
}

##############################################################################
# Main routine
##############################################################################

$| = 1;
$FULLPATH = $0;
$0 =~ s%.*/%%;

# Load overrides from the user's home directory, if applicable.
if (-r "$ENV{HOME}/.spinrc") { do "$ENV{HOME}/.spinrc" }

# Parse command-line options.
my ($help, $version, $filter);
$STYLES = '';
Getopt::Long::config ('bundling');
GetOptions ('filter|f'      => \$filter,
            'help|h'        => \$help,
            'style-url|s=s' => \$STYLES,
            'version|v'     => \$version) or exit 1;
if ($help) {
    print "Feeding myself to perldoc, please wait....\n";
    exec ('perldoc', '-t', $FULLPATH);
} elsif ($version) {
    my $version = join (' ', (split (' ', $ID))[1..3]);
    $version =~ s/,v\b//;
    $version =~ s/(\S+)$/($1)/;
    $version =~ tr%/%-%;
    print $version, "\n";
    exit;
}
$STYLES =~ s%/*$%/% if $STYLES;

# The arguments depend on whether -f is given.  If it is, just filter stdin to
# stdout; otherwise, take the input tree and the output tree on the command
# line and process the input into the output.
if ($filter) {
    if (@ARGV) { die "Usage: $0 -f\n" }
    spin ('-', '-');
} else {
    if (@ARGV != 2) { die "Usage: $0 <source> <output>\n" }
    ($SOURCE, $OUTPUT) = @ARGV;
    $File::Find::dont_use_nlink = 1;
    find (\&process_file, $SOURCE);
}

##############################################################################
# Documentation
##############################################################################

=head1 NAME

spin - Translate thread, an HTML macro language, into XHTML

=head1 SYNOPSIS

spin [B<-hv>] [B<-s> I<url>] I<source> I<output>

spin [B<-s> I<url>] B<-f>

=head1 REQUIREMENTS

Perl 5.005 or later and the Image::Size and Text::Balanced modules.  Also
expects to find B<faq2html>, B<cvs2xhtml>, and B<cl2xhtml> to convert
certain types of files.

=head1 DESCRIPTION

B<spin> implements a fairly simple macro language that expands out into
XHTML, as well as serving as a tool to maintain a set of web pages, updating
a staging area with the latest versions, converting pages written in the
macro language (named "thread"), and running B<faq2html> where directed.

When invoked with the B<-f> option, B<spin> works in filter mode, reading
thread from stdin and writing the converted output to stdout.  Some
features, such as appending a signature or navigation links, are disabled in
this mode.

Otherwise, for each file in the directory I<source>, recursively through the
directory structure, it is either copied verbatim into the same relative
path under I<output> or converted to HTML with the HTML output put under
I<output> with the same file name but with the extension changed to
C<.html>.  Missing directories are created.  Files that end in C<.th> are
assumed to be in thread and are turned into HTML.

Files that end in C<.faq> are assumed to contain a path to a text FAQ, which
is run through B<faq2html> and the output is saved into I<output>.  If there
is a second line in the C<.faq> file, it is taken to be the style sheet that
should be used for the output; otherwise, C<faq.css> is used.

Files that end in C<.log> are assumed to contain a path to a file on which
CVS log should be run, the results of which are run through B<cvs2xhtml> and
saved to I<output>.

Files that end in C<.rpod> are assumed to contain a path to a file on which
B<pod2thread> and C<spin -f> are run to generate the output.

Files that end in C<.changelog> are assumed to contain a path to a GNU-style
ChangeLog file on which B<cl2xhtml> is run to generate the output and the
package to which that ChangeLog applies on the second line.

All other files not beginning with a period are copied as-is.

The exact details of the macro language are as yet not documented.  The
basic format, however, is that macro invocations start with C<\>, take an
optional initial argument specifying the class (in the style sheet sense,
resulting in a class attribute in the XHTML to which a style sheet can
refer) enclosed in parentheses, and then some number of arguments enclosed
in square brackets.  Any amount of space can separate the macro name from
the class argument or regular arguments, or the arguments from each other,
and that whitesepace is ignored.

In addition, a new macro can be defined using syntax like:

    \==[name] [arguments] [definition]

where name is the name of the macro, arguments is the number of arguments
that it takes, and definition is the definition of the macro, in which \1 is
replaced by the first argument, \2 by the second argument, and so forth.

Similarly, strings can be defined with:

    \=[name] [value]

and then later referred to in the page with \=name.  This is useful for
things like URLs for links, so that they're all collected at the top of the
page for easy updating.

Paragraphs can be left without markup and will automatically be wrapped in
HTML <p> tags.  The content of macros can span paragraphs.  Macros can be
nested arbitrarily.

Each page should begin with an \id macro containing an RCS Id string, and
then a \header macro specifying the page title and style sheet; this will
set up the proper XHTML headers.  Each page should also end with \signature,
which will append the navigation links and an address block.

B<spin> looks for a file named F<.placement> in the same directory as a
thread file and reads it for navigation information to generate the
navigation links at the bottom of the page.  The format of this file is a
list of partial URLs, whitespace, and their page titles, one per line,
followed by a line consisting of three dashes, and then names of HTML files
in that directory followed by three space-separated partial URLs.  These
partial URLs specify the next page, the previous page, and the "up" page in
that order.  If any of these should not be given, use C<!> as the value of
that field.

B<spin> also looks for a file named F<.signature> in the same directory as a
thread file and uses its contents as the basis of the <address> block at the
end of the XHTML page.  The contents will be surrounded by an <address> tag
and added to the end will be information about when the page was last
modified and generated.

=head1 OPTIONS

=over 4

=item B<-f>, B<--filter>

Run B<spin> in filter mode rather than converting a whole tree of files.
Thread source is read from stdin and the XHTML output is written to stdout.
The signature and navigation links are disabled.

=item B<-h>, B<--help>

Print out this documentation (which is done simply by feeding the script to
C<perldoc -t>).

=item B<-s> I<url>, B<--style-url>=I<url>

The base URL for style sheets.  All style sheets specified in \heading
commands will be considered to be relative to this URL and this URL will be
prepended to them (otherwise, they'll be referred to as if they're in the
same directory as the generated file).  This will similarly be used as the
base URL to style sheets for the output of B<cl2xhtml>, B<cvs2xhtml>, and
B<faq2html>.

=item B<-v>, B<--version>

Print out the version of B<spin> and exit.

=back

=head1 BUGS

Currently, the style sheets for B<cl2xhtml>, B<cvs2xhtml>, B<faq2html>, and
B<pod2thread> are hard-coded into this program to fit my web pages.  This
makes this program rather unsuitable for use by anyone other than me.

This documentation is woefully incomplete; there should really be a
description of all of the pre-defined macros.

The \p macro is rather ugly and doesn't fit well with the rest of spin; what
should instead happen is that a \class that spans a complete paragraph
should be lifted into the surrounding paragraph.  This is a bit tricky to do
in the current architecture.

There is a lot of duplicate code in B<spin> right now for dealing with the
different processors that needs to be rethought and abstracted out.

=head1 NOTES

The proper <link> tags representing the page hierarchy should really be
added to the header for the benefit of clients that can use them for
navigation information.

=head1 SEE ALSO

cl2xhtml(1), cvs2xhtml(1), faq2html(1), pod2thread(1)

The XHTML 1.0 standard at L<http://www.w3.org/TR/xhtml1/>.

Current versions of this program are available from my web tools page at
L<http://www.eyrie.org/~eagle/software/web/>, as are copies of all of the
above-mentioned programs.

=head1 AUTHOR

Russ Allbery <rra@stanford.edu>

=head1 COPYRIGHT AND LICENSE

Copyright 1999, 2000, 2001, 2002 by Russ Allbery <rra@stanford.edu>.

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.

=cut
