#!/usr/bin/perl -w
$ID = q$Id$;
#
# spin -- Translate thread (an HTML macro language) into HTML.
#         Copyright 1999, 2000, 2001, 2002 by Russ Allbery <rra@stanford.edu>
#
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

##############################################################################
# Modules and declarations
##############################################################################

require 5.005;

use strict;
use subs qw(expand parse);
use vars qw($DOCID $FILE $ID $OUT $OUTPUT $SOURCE $SPACE $SPINID @STATE
            %commands %strings);

use Getopt::Long qw(GetOptions);
use Image::Size qw(html_imgsize);
use File::Copy qw(copy);
use File::Find qw(find);
use POSIX qw(strftime);
use Text::Balanced qw(extract_bracketed);

##############################################################################
# Output
##############################################################################

# Sends something to the output file without deferring spaces and without
# printing out pending spaces.
sub literal { print OUT join ('', @_) }

# Sends something to the output file.
sub output {
    if ($SPACE) {
        print OUT $SPACE;
        $SPACE = '';
    }
    my $output = join ('', @_);
    if ($output =~ s/\n(\s*)\z/\n/) { $SPACE = $1 }
    print OUT $output;
}

##############################################################################
# Basic parsing
##############################################################################

# Escapes &, <, and > characters found in a string.
sub escape { local $_ = shift; s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g; $_ }

# Opens or closes a border of a continued structure.  Either takes the name of
# the state and its start and end tags, or takes no arguments to close all
# open states.
sub border {
    my ($border, $start, $end) = @_;
    if ($border) {
        if (!@STATE || $STATE[0][0] ne $border) {
            output $start;
            unshift (@STATE, [ $border, $end ]);
        }
    } else {
        for (@STATE) { literal $$_[1] }
        undef @STATE;
    }
}

# Extract some number of arguments from the front of the given string.  If the
# optional third argument is true, try to pull off a parenthesized formatting
# instruction first, returning it as the first result (or undef if it's not
# found).
sub extract {
    my ($text, $count, $format) = @_;
    my (@result, $code);
    $text =~ s/\s*//;
    if ($format && $text =~ /^\(/) {
        ($result[0], $text) = extract_bracketed ($text, '()');
        $result[0] = substr ($result[0], 1, -1);
    } else {
        $result[0] = '';
    }
    for (1..$count) {
        ($result[$_], $text) = extract_bracketed ($text, '[]');
        if ($result[$_]) {
            $result[$_] = substr ($result[$_], 1, -1);
        } else {
            warn "$0:$FILE:$.: Can't find argument $_\n";
        }
    }
    unless ($format) { shift @result }
    (@result, $text);
}

# Delcare a new command.  Takes the command name, the number of arguments, and
# the definition as arguments.  Only straight substitution commands are
# allowed here, of course.  The body of the command isn't parsed at this
# stage; it's parsed later when the command is actually invoked.
sub declare {
    my ($command, $args, $definition) = @_;
    my $handler = sub {
        local $_ = $commands{$command}[2];
        s/\\(\d+)/($1 > $args) ? "\\$1" : $_[$1]/ge;
        parse ($_);
    };
    $commands{$command} = [ $args, $handler, $definition ];
}

# Expand a given command into its representation.  This function is mutually
# recursive with parse.
sub expand {
    my ($command, $text) = @_;
    if ($command eq '==') {
        my ($new, $args, $definition);
        ($new, $args, $definition, $text) = extract ($text, 3);
        declare ($new, $args, $definition);
        return ('', $text);
    } elsif ($command eq '=') {
        my ($variable, $value);
        ($variable, $value, $text) = extract ($text, 2);
        $strings{$variable} = parse $value;
        return ('', $text);
    } elsif ($command =~ s/^=//) {
        return ($strings{$command}, $text);
    } elsif ($command eq '\\') {
        return ('\\', $text);
    } else {
        if (!ref $commands{$command}) {
            die "$0:$FILE:$.: bad command $command\n";
        }
        my ($args, $handler) = @{$commands{$command}};
        if ($args == 0) {
            return (&$handler (), $text);
        } else {
            my @args = extract ($text, $args, 1);
            $text = pop @args;
            my $format = shift @args;
            for (@args) { $_ = parse $_ }
            return (&$handler ($format, @args), $text);
        }
    }
}

# Given a text string, check it for escape sequences.  If there are any,
# expand them, returning the final string after all expansions have been done.
# This function is mutually recursive with expand.
sub parse {
    my ($text, $top) = @_;
    if (index ($text, '\\') == -1) {
        if ($top) {
            border;
            $text =~ s%\n(\s*)\z%\n</p>\n$1%;
            return "<p>\n" . $text;
        } else {
            return $text;
        }
    }

    # Chop off everything up to the first backslash and save it in output.
    # Then grab the escape and figure out what to do with it.
    my $output;
    while ($text) {
        $text =~ s/^([^\\]*)(?:\\([\w=]+|.))?//
            or die "$0:$FILE:$.: unable to parse at '"
                . substr ($text, 0, 20) . "'";
        $output .= $1;
        my $command = $2;
        if ($command) {
            my $result;
            ($result, $text) = expand ($command, $text);
            $output .= $result;
        }
    }
    if ($top && $output =~ /\S/) {
        border;
        $output =~ s/^/<p>\n/;
        $output =~ s%\n(\s*)\z%\n</p>\n$1%;
    }
    $output;
}

##############################################################################
# Page placement
##############################################################################

# Given the name of the current file being processed, opens a .placement file
# if available and outputs the navigation links for that file.  If no
# .placement file is present, nothing is output.
sub placement {
    my $file = shift;

    # Grab placement information for links if we have it.
    if (open (PLACEMENT, '.placement')) {
        local $_;
        local $/ = "\n";
        my (%titles, @placement);
        while (<PLACEMENT>) {
            next if /^\s*$/;
            last if /---/;
            my ($page, $title) = split (' ', $_, 2);
            chomp $title;
            $titles{$page} = $title;
        }
        while (<PLACEMENT>) {
            if (/^$file\s/) {
                chomp;
                @placement = split;
                shift @placement;
                last;
            }
        }
        close PLACEMENT;
        unless (@placement) {
            die "$0: can't find placement for $file\n";
        }
        @placement = map { $_ eq '!' ? undef : $_ } @placement;
        unless ($placement[0] || $placement[1] || $placement[2]) {
            return;
        }

        my @text = ('Onward to', 'Back to', 'Return to');
        my $br = '';
        output qq(<p class="navigation">\n);
        for my $i (0..2) {
            next unless defined $placement[$i];
            my $href = '<a href="' . $placement[$i] . '">' .
                $titles{$placement[$i]} . '</a>';
            $href =~ s/^(<[^>]+>)the /the $1/;
            output $br, '    ', $text[$i], ' ', $href;
            $br = " <br />\n";
        }
        output "\n</p>\n\n";
    }
}

# Print out the signature file for pages in this directory, if present.
sub sign {
    if (open (SIG, '< .signature')) {
        local $/ = "\n";
        my @signature = <SIG>;
        chomp @signature;
        close SIG;
        output join ("\n    ", @signature);
        output " <br />\n    ";
    }
}

##############################################################################
# Basic commands
##############################################################################

# Basic commands that only print some simple output.
sub do_break  { '<br />' }
sub do_cite   { '<cite>' . $_[1] . '</cite>' }
sub do_code   { '<code>' . $_[1] . '</code>' }
sub do_bold   { '<strong>' . $_[1] . '</strong>' }
sub do_emph   { '<em>' . $_[1] . '</em>' }
sub do_italic { '<i>' . $_[1] . '</i>' }
sub do_link   { '<a href="' . $_[1] . '">' . $_[2] . '</a>' }
sub do_rule   { border; output "<hr />\n\n"; '' }

# A blockquote, used primarily to indent a section of text that's being
# referred to by the main text.
sub do_block {
    my ($format, $text) = @_;
    $text =~ s%\n\n\s*(\S)%\n</p>\n\n<p>$1%g;
    $text =~ s/\s*\n+$//;
    output "<blockquote>\n<p>\n$text</p>\n</blockquote>\n\n";
    '';
}

# An item in a bulletted list.  If not already in a bulletted list, one is
# opened for this element.  The items are surrounded by paragraph markers,
# which on some browsers will create extra whitespace around the item (often
# not suitable for lists where each element is a single line).
sub do_bullet {
    my ($format, $text) = @_;
    border ('bullet', "<ul>\n", "</ul>\n");
    $text =~ s%\n\n\s*(\S)%\n</p>\n\n<p>$1%g;
    $text =~ s%\s*\n+$%%;
    if ($format) {
        output qq(<li class="$format"><p>$text</p></li>\n\n);
    } else {
        output qq(<li><p>$text</p></li>\n\n);
    }
    '';
}

# An item in a bulletted list.  If not already in a bulletted list, one is
# opened for this element.  The items are not surrounded by paragraph markers,
# which will make the list more compact on some browsers.
sub do_packbullet {
    my ($format, $text) = @_;
    border ('bullet', "<ul>\n", "</ul>\n");
    $text =~ s%\s*\n+$%%;
    if ($format) {
        output qq(<li class="$format">$text</li>\n\n);
    } else {
        output qq(<li>$text</li>\n\n);
    }
    '';
}

# Set a class (for style sheets) for the enclosing text.  This should be used
# inside text elements (like regular paragraphs).
sub do_class {
    my ($format, $text) = @_;
    if ($format) {
        qq(<span class="$format">$text</span>);
    } else {
        $text;
    }
}

# A description list entry, which takes the heading and the body as arguments.
# If one is not already open, a description list will be opened automatically
# for this element.
sub do_desc {
    my ($format, $heading, $text) = @_;
    border ('desc', "<dl>\n", "</dl>\n");
    $text =~ s%\n\n\s*(\S)%\n</p>\n\n<p>$1%g;
    $text =~ s/\s*\n\n+$/\n/;
    output "<dt>$heading</dt>\n<dd><p>$text</p></dd>\n\n";
    '';
}

# The handler for all the headings, of any level.  Essentially the same as the
# HTML tag.
sub do_h {
    my ($level, $format, $text) = @_;
    border;
    if ($format) {
        output qq(<h$level class="$format">$text</h$level>\n\n);
    } else {
        output qq(<h$level>$text</h$level>\n\n);
    }
    '';
}

# Generates the page heading at the top of the document.  Takes as arguments
# the page title and the page style.  This is where the XHTML declarations
# come from.
sub do_heading {
    my ($format, $title, $style) = @_;
    output qq(<?xml version="1.0" encoding="iso-8859-1"?>\n);
    output qq(<!DOCTYPE html\n);
    output qq(    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"\n);
    output qq(    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">\n);
    if ($style) {
        $style .= '.css';
        output qq(<?xml-stylesheet href="$style" type="text/css"?>\n);
    }
    output "\n<!-- $SPINID -->\n<!-- $DOCID -->\n\n";
    output qq(<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en");
    output qq( lang="en">\n);
    output qq(<head>\n  <title>$title</title>\n);
    if ($style) {
        output qq(  <link rel="stylesheet" href="$style" type="text/css" />);
        output "\n";
    }
    output "</head>\n\n<body>\n\n";
    '';
}

# Used to save the RCS Id for the document.  Doesn't actually output anything
# (the identifier is later used in do_heading).
sub do_id {
    my ($format, $id) = @_;
    $DOCID = $id;
    '';
}

# Include an image.  The size is added to the HTML tag automatically.  Takes
# the relative path to the image and the alt text.
sub do_image {
    my ($format, $image, $text) = @_;
    my $size = lc html_imgsize ($image);
    if ($format) {
        qq(<img src="$image" alt="$text" $size class="$format" />);
    } else {
        qq(<img src="$image" alt="$text" $size />);
    }
}

# An HTML paragraph tag.  Normally, this isn't needed, but it's the only way
# to set a class for a whole paragraph (rather than just part of a paragraph)
# and is therefore currently needed in a few places.  Sort of an ugly wart;
# maybe I should get rid of it at some point.
sub do_p {
    my ($format, $text) = @_;
    if ($format) {
        output qq(<p class="$format">$text</p>\n\n);
    } else {
        output qq(<p>$text</p>\n\n);
    }
    '';
}

# Preformatted text, the same as the HTML tag.
sub do_pre {
    my ($format, $text) = @_;
    if ($format) {
        output qq(<pre class="$format">$text</pre>\n\n);
    } else {
        output qq(<pre>$text</pre>\n\n);
    }
    '';
}

# Used for the leading quotes that I have on many of my pages.  Takes the
# quote, the author, and the citation; the citation may be empty.  If the
# format is "broken", adds line breaks at the end of each line.
sub do_quote {
    my ($format, $quote, $author, $cite) = @_;
    border;
    if ($format && $format eq 'broken') {
        $quote =~ s%(\S *)(\n\s*\S)%$1<br />$2%g;
    }
    my $output;
    if ($format) {
        $output = qq(<blockquote class="$format"><p class="$format">);
    } else {
        $output = '<blockquote><p>';
    }
    output $output . $quote . "</p>";
    if ($author) {
        output qq(<p class="attribution">\n);
        if ($cite) {
            output "    $author,\n    $cite\n";
        } else {
            output "    $author\n";
        }
        output "</p>";
    } else {
        output "\n";
    }
    output "</blockquote>\n\n";
    '';
}

# Used to end each page, this adds the navigation links and my standard
# address block.
sub do_signature {
    border;
    if ($FILE eq '-') {
        output "</body>\n</html>\n";
        return '';
    }
    my $file = $FILE;
    $file =~ s/\.th$/.html/;
    placement $file;

    # Figure out the modified dates and print out the rest of the footer.
    my $modified = (split (' ', $DOCID))[3];
    if ($modified) {
        $modified =~ s{^(\d+)/(\d+)/(\d+)}{
            sprintf ("%d-%02d-%02d", $1, $2, $3)
        }e;
    } else {
        $modified = strftime ('%Y-%m-%d', gmtime ((stat $FILE)[9]));
    }
    my $spun = strftime ('%Y-%m-%d', gmtime);
    if ($modified eq $spun) {
        $modified = 'Last modified and spun ' . $modified;
    } else {
        $modified = "Last spun $spun from thread modified $modified";
    }
    output "<address>\n    ";
    sign;
    output "$modified\n</address>\n</body>\n</html>\n";
    '';
}

# The table of available commands.
%commands = (block      => [ 1, \&do_block      ],
             break      => [ 0, \&do_break      ],
             bullet     => [ 1, \&do_bullet     ],
             class      => [ 1, \&do_class      ],
             cite       => [ 1, \&do_cite       ],
             code       => [ 1, \&do_code       ],
             bold       => [ 1, \&do_bold       ],
             desc       => [ 2, \&do_desc       ],
             emph       => [ 1, \&do_emph       ],
             heading    => [ 2, \&do_heading    ],
             id         => [ 1, \&do_id         ],
             image      => [ 2, \&do_image      ],
             italic     => [ 1, \&do_italic     ],
             link       => [ 2, \&do_link       ],
             p          => [ 1, \&do_p          ],
             packbullet => [ 1, \&do_packbullet ],
             pre        => [ 1, \&do_pre        ],
             quote      => [ 3, \&do_quote      ],
             rule       => [ 0, \&do_rule       ],
             signature  => [ 0, \&do_signature  ]);

for (1..6) { $commands{"h$_"} = [ 1, eval "sub { do_h ($_, \@_) }" ] }

##############################################################################
# Interface
##############################################################################

# This function is called, giving an input and an output file name, to spin
# HTML from thread.
sub spin {
    my ($thread, $output) = @_;
    $FILE = $thread;
    open (IN, $thread) or die "$0: can't open $thread: $!\n";
    open (OUT, "> $output") or die "$0: can't create $output: $!\n";
    $OUT = \*OUT;

    # Add our initial comment.
    my $version = (split (' ', $ID))[2];
    my $date = strftime ('%Y-%m-%d %T -0000', gmtime);
    $SPINID = "Spun from " . ($thread eq '-' ? 'stdin' : $thread)
        . " by spin $version on $date";

    # Parse the thread file a paragraph at a time (but pick up macro contents
    # that are continued across paragraphs.
    local $/ = '';
    local $_;
    while (<IN>) {
        my $open = tr/\[//;
        my $close = tr/\]//;
        while (!eof && $open > $close) {
            my $extra = <IN>;
            $open += ($extra =~ tr/\[//);
            $close += ($extra =~ tr/\]//);
            $_ .= $extra;
        }
        my $result = parse (escape ($_), 1);
        output $result unless ($result =~ /^\s*$/);
    }
    output '';
    close IN;
    close OUT;
}

##############################################################################
# Per-file operations
##############################################################################

# A wrapper around the cvs2xhtml script, used to handle .log pointers in a
# tree being spun.  Adds the navigation links and the signature to the
# cvs2xhtml output.
sub cvs2xhtml {
    my ($source, $output) = @_;
    my $dir = $source;
    $dir =~ s%/+[^/]+$%%;
    my $name = $source;
    $name =~ s%^.*/%%;
    my $style = '/~eagle/styles/cvs.css';
    my @page = `(cd $dir && cvs log $source) | cvs2xhtml -n $name -s $style`;
    open (OUT, "> $output") or die "$0: can't create $output: $!\n";
    $OUT = \*OUT;

    # Grab the first few lines of input, looking for a blurb.  Give up if we
    # encounter <html> first.
    my $blurb;
    local $_;
    while (defined ($_ = shift @page)) {
        last if /<html>/i;
        if (/<!--\s*(Generated.*?)\s*-->/) {
            $blurb = $1;
            $blurb =~ s/ \d\d:\d\d:\d\d -0000//;
            $blurb =~ s/ \(\d{4}-\d\d-\d\d\)//;
            last;
        }
        print OUT $_;
    }
    print OUT $_;

    # Snarf input and write it to output until we see </body>, which is our
    # signal to start adding things.  We just got very confused if </body> was
    # on the same line as <html>, so don't do that.
    print $OUT $_ while (defined ($_ = shift @page) && !m%</body>%i);
    print OUT "\n";

    # Print out our separator line and placement information, if any.
    my $file = $output;
    $file =~ s%^.*/%%;
    placement $file;

    # Print out the signature and blurb.
    output "<address>\n    ";
    sign;
    output "$blurb\n</address>\n\n";

    # Finish with the cvs2xhtml output.
    print $OUT $_, @page;
}

# A wrapper around the faq2html script, used to handle .faq pointers in a tree
# being spun.  Adds the navigation links and the signature to the faq2html
# output.
sub faq2html {
    my ($source, $output) = @_;
    my @page = `faq2html -s '/~eagle/styles/faq.css' $source`;
    open (OUT, "> $output") or die "$0: can't create $output: $!\n";
    $OUT = \*OUT;

    # Grab the first few lines of input, looking for a blurb.  Give up if we
    # encounter <html> first.
    my $blurb;
    local $_;
    while (defined ($_ = shift @page)) {
        last if /<html>/i;
        if (/<!--\s*(Converted.*)\s*-->/) { $blurb = $1; last }
        print OUT $_;
    }
    print OUT $_;

    # Snarf input and write it to output until we see </body>, which is our
    # signal to start adding things.  We just got very confused if </body> was
    # on the same line as <html>, so don't do that.
    print $OUT $_ while (defined ($_ = shift @page) && !m%</body>%i);
    print OUT "\n";

    # Print out our separator line and placement information, if any.
    my $file = $output;
    $file =~ s%^.*/%%;
    placement $file;

    # Print out the signature and blurb.
    output "<address>\n    ";
    sign;
    output "$blurb\n</address>\n\n";

    # Finish with the faq2html output.
    print $OUT $_, @page;
}

# This routine is called for every file in the source tree, and references the
# variables $SOURCE and $OUTPUT to find the roots of the source and output
# tree.  It decides what to do with each file, whether spinning it or copying
# it.  It's called from within File::Find and therefore uses the standard
# File::Find variables.
sub process_file {
    return if /^\./;
    $File::Find::prune = 1, return if $_ eq 'CVS';
    my $input = $File::Find::name;
    my $output = $input;
    $output =~ s/^\Q$SOURCE/$OUTPUT/ or die "$0: $input out of tree?\n";
    my $shortout = $output;
    $shortout =~ s/^\Q$OUTPUT/.../;
    if (-d && -d $output) {
        return;
    } elsif (-d && !-d $output) {
        if (-e $output) {
            die "$0: can't replace $output with a directory\n";
        } else {
            mkdir ($output, 0755) or die "$0: mkdir $output failed: $!\n";
        }
    } elsif (/.faq$/) {
        $output =~ s/\.faq$/.html/;
        $shortout =~ s/\.faq$/.html/;
        open (POINTER, $input) or die "$0: can't open $input: $!\n";
        my $master = <POINTER>;
        close POINTER;
        chomp $master;
        return if (-e $output && -M $master >= -M $output);
        print "Formatting $shortout\n";
        faq2html ($master, $output);
    } elsif (/\.log$/) {
        $output =~ s/\.log$/.html/;
        $shortout =~ s/\.log$/.html/;
        open (POINTER, $input) or die "$0: can't open $input: $!\n";
        my $file = <POINTER>;
        close POINTER;
        chomp $file;
        return if (-e $output && -M $file >= -M $output);
        print "Generating log for $shortout\n";
        cvs2xhtml ($file, $output);
    } elsif (/\.th$/) {
        $output =~ s/\.th$/.html/;
        $shortout =~ s/\.th$/.html/;
        return if (-e $output && -M $_ >= -M $output);
        print "Spinning $shortout\n";
        spin ($_, $output);
    } elsif (!-e $output || -M $_ < -M $output) {
        print "Updating $shortout\n";
        copy ($_, $output)
            or die "$0: copy of $input to $output failed: $!\n";
    }
}

##############################################################################
# Main routine
##############################################################################

$| = 1;
$0 =~ s%.*/%%;

# Load overrides from the user's home directory, if applicable.
if (-r "$ENV{HOME}/.spinrc") { do "$ENV{HOME}/.spinrc" }

# Parse command-line options.
my ($help, $version, $filter);
Getopt::Long::config ('bundling');
GetOptions ('filter|f'  => \$filter,
            'help|h'    => \$help,
            'version|v' => \$version) or exit 1;
if ($help) {
    print "Feeding myself to perldoc, please wait....\n";
    exec ('perldoc', '-t', $0);
} elsif ($version) {
    my $version = join (' ', (split (' ', $ID))[1..3]);
    $version =~ s/,v\b//;
    $version =~ s/(\S+)$/($1)/;
    die $version, "\n";
}

# The arguments depend on whether -f is given.  If it is, just filter stdin to
# stdout; otherwise, take the input tree and the output tree on the command
# line and process the input into the output.
if ($filter) {
    if (@ARGV) { die "Usage: $0 -f\n" }
    spin ('-', '-');
} else {
    if (@ARGV != 2) { die "Usage: $0 <source> <output>\n" }
    ($SOURCE, $OUTPUT) = @ARGV;
    $File::Find::dont_use_nlink = 1;
    find (\&process_file, $SOURCE);
}

##############################################################################
# Documentation
##############################################################################

=head1 NAME

spin - Translate thread, an HTML macro language, into XHTML

=head1 SYNOPSIS

spin [B<-hv>] I<source> I<output>

spin B<-f>

=head1 REQUIREMENTS

Perl 5.005 or later and the Image::Size and Text::Balanced modules.  Also
expects to find B<faq2html> and B<cvs2xhtml> to convert certain types of
files.

=head1 DESCRIPTION

B<spin> implements a fairly simple macro language that expands out into
XHTML, as well as serving as a tool to maintain a set of web pages, updating
a staging area with the latest versions, converting pages written in the
macro language (named "thread"), and running B<faq2html> where directed.

When invoked with the B<-f> option, B<spin> works in filter mode, reading
thread from stdin and writing the converted output to stdout.  Some
features, such as appending a signature or navigation links, are disabled in
this mode.

Otherwise, for each file in the directory I<source>, recursively through the
directory structure, it is either copied verbatim into the same relative
path under I<output> or converted to HTML with the HTML output put under
I<output> with the same file name but with the extension changed to
C<.html>.  Missing directories are created.  Files that end in C<.th> are
assumed to be in thread and are turned into HTML.  Files that end in C<.faq>
are assumed to contain a path to a text FAQ, which is run through
B<faq2html> and the output is saved into I<output>.  Files that end in
C<.log> are assumed to contain a path to a file on which CVS log should be
run, the results of which are run through B<cvs2xhtml> and saved to
I<output>.  All other files not beginning with a period are copied as-is.

The exact details of the macro language are as yet not documented.  The
basic format, however, is that macro invocations start with C<\>, take an
optional initial argument specifying the class (in the style sheet sense,
resulting in a class attribute in the XHTML to which a style sheet can
refer) enclosed in parentheses, and then some number of arguments enclosed
in square brackets.  Any amount of space can separate the macro name from
the class argument or regular arguments, or the arguments from each other,
and that whitesepace is ignored.

In addition, a new macro can be defined using syntax like:

    \==[name] [arguments] [definition]

where name is the name of the macro, arguments is the number of arguments
that it takes, and definition is the definition of the macro, in which \1 is
replaced by the first argument, \2 by the second argument, and so forth.

Similarly, strings can be defined with:

    \=[name] [value]

and then later referred to in the page with \=name.  This is useful for
things like URLs for links, so that they're all collected at the top of the
page for easy updating.

Paragraphs can be left without markup and will automatically be wrapped in
HTML <p> tags.  The content of macros can span paragraphs.  Macros can be
nested arbitrarily.

Each page should begin with an \id macro containing an RCS Id string, and
then a \header macro specifying the page title and style sheet; this will
set up the proper XHTML headers.  Each page should also end with \signature,
which will append the navigation links and an address block.

B<spin> looks for a file named F<.placement> in the same directory as a
thread file and reads it for navigation information to generate the
navigation links at the bottom of the page.  The format of this file is a
list of partial URLs, whitespace, and their page titles, one per line,
followed by a line consisting of three dashes, and then names of HTML files
in that directory followed by three space-separated partial URLs.  These
partial URLs specify the next page, the previous page, and the "up" page in
that order.  If any of these should not be given, use C<!> as the value of
that field.

B<spin> also looks for a file named F<.signature> in the same directory as a
thread file and uses its contents as the basis of the <address> block at the
end of the XHTML page.  The contents will be surrounded by an <address> tag
and added to the end will be information about when the page was last
modified and generated.

=head1 OPTIONS

=over 4

=item B<-f>, B<--filter>

Run B<spin> in filter mode rather than converting a whole tree of files.
Thread source is read from stdin and the XHTML output is written to stdout.
The signature and navigation links are disabled.

=item B<-h>, B<--help>

Print out this documentation (which is done simply by feeding the script to
C<perldoc -t>).

=item B<-v>, B<--version>

Print out the version of B<cvslog> and exit.

=back

=head1 BUGS

This documentation is woefully incomplete; there should really be a
description of all of the pre-defined macros.

The \p macro is rather ugly and doesn't fit well with the rest of spin; what
should instead happen is that a \class that spans a complete paragraph
should be lifted into the surrounding paragraph.  This is a bit tricky to do
in the current architecture.

=head1 NOTES

The proper <link> tags representing the page hierarchy should really be
added to the header for the benefit of clients that can use them for
navigation information.

=head1 AUTHOR

Russ Allbery <rra@stanford.edu>

=head1 COPYRIGHT AND LICENSE

Copyright 1999, 2000, 2001, 2002 by Russ Allbery <rra@stanford.edu>.

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.

=cut
