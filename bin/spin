#!/usr/bin/perl -w
$ID = q$Id$;
#
# spin -- Translate thread (an HTML macro language) into HTML.
#         Copyright 1999, 2000 by Russ Allbery <rra@stanford.edu>
#
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

############################################################################
# Modules and declarations
############################################################################

require 5.005;

use strict;
use subs qw(expand parse);
use vars qw($DOCID $FILE $ID $OUT $OUTPUT $SOURCE $SPACE @STATE %commands
            %strings);

use Image::Size qw(html_imgsize);
use File::Copy qw(copy);
use File::Find qw(find);
use POSIX qw(strftime);
use Text::Balanced qw(extract_bracketed);


############################################################################
# Output
############################################################################

# Sends something to the output file without deferring spaces and without
# printing out pending spaces.
sub literal { print OUT join ('', @_) }

# Sends something to the output file.
sub output {
    if ($SPACE) {
        print OUT $SPACE;
        $SPACE = '';
    }
    my $output = join ('', @_);
    if ($output =~ s/\n(\s*)\z/\n/) { $SPACE = $1 }
    print OUT $output;
}


############################################################################
# Basic parsing
############################################################################

# Escapes &, <, and > characters found in a string.
sub escape { local $_ = shift; s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g; $_ }

# Opens or closes a border of a continued structure.  Either takes the name
# of the state and its start and end tags, or takes no arguments to close
# all open states.
sub border {
    my ($border, $start, $end) = @_;
    if ($border) {
        if (!@STATE || $STATE[0][0] ne $border) {
            output $start;
            unshift (@STATE, [ $border, $end ]);
        }
    } else {
        for (@STATE) { literal $$_[1] }
        undef @STATE;
    }
}

# Extract some number of arguments from the front of the given string.  If
# the optional third argument is true, try to pull off a parenthesized
# formatting instruction first, returning it as the first result (or undef
# if it's not found).
sub extract {
    my ($text, $count, $format) = @_;
    my (@result, $code);
    $text =~ s/\s*//;
    if ($format && $text =~ /^\(/) {
        ($result[0], $text) = extract_bracketed ($text, '()');
        $result[0] = substr ($result[0], 1, -1);
    } else {
        $result[0] = '';
    }
    for (1..$count) {
        ($result[$_], $text) = extract_bracketed ($text, '[]');
        $result[$_] = substr ($result[$_], 1, -1);
    }
    unless ($format) { shift @result }
    (@result, $text);
}

# Delcare a new command.  Takes the command name, the number of arguments,
# and the definition as arguments.  Only straight substitution commands are
# allowed here, of course.  The body of the command isn't parsed at this
# stage; it's parsed later when the command is actually invoked.
sub declare {
    my ($command, $args, $definition) = @_;
    my $handler = sub {
        local $_ = $commands{$command}[2];
        s/\\(\d+)/($1 > $args) ? "\\$1" : $_[$1]/ge;
        parse ($_);
    };
    $commands{$command} = [ $args, $handler, $definition ];
}

# Expand a given command into its representation.  This function is mutually
# recursive with parse.
sub expand {
    my ($command, $text) = @_;
    if ($command eq '==') {
        my ($new, $args, $definition);
        ($new, $args, $definition, $text) = extract ($text, 3);
        declare ($new, $args, $definition);
        return ('', $text);
    } elsif ($command eq '=') {
        my ($variable, $value);
        ($variable, $value, $text) = extract ($text, 2);
        $strings{$variable} = parse $value;
        return ('', $text);
    } elsif ($command =~ s/^=//) {
        return ($strings{$command}, $text);
    } else {
        if (!ref $commands{$command}) {
            die "$0:$FILE:$.: bad command $command\n";
        }
        my ($args, $handler) = @{$commands{$command}};
        if ($args == 0) {
            return (&$handler (), $text);
        } else {
            my @args = extract ($text, $args, 1);
            $text = pop @args;
            my $format = shift @args;
            for (@args) { $_ = parse $_ }
            return (&$handler ($format, @args), $text);
        }
    }
}

# Given a text string, check it for escape sequences.  If there are any,
# expand them, returning the final string after all expansions have been
# done.  This function is mutually recursive with expand.
sub parse {
    my ($text, $top) = @_;
    if (index ($text, '\\') == -1) {
        if ($top) {
            border;
            $text =~ s%\n(\s*)\z%\n</p>\n$1%;
            return "<p>\n" . $text;
        } else {
            return $text;
        }
    }

    # Chop off everything up to the first backslash and save it in output.
    # Then grab the escape and figure out what to do with it.
    my $output;
    while ($text) {
        $text =~ s/^([^\\]*)(?:\\([\w=]+|.))?//
            or die "$0:$FILE:$.: unable to parse at '"
                . substr ($text, 0, 20) . "'";
        $output .= $1;
        my $command = $2;
        if ($command) {
            my $result;
            ($result, $text) = expand ($command, $text);
            $output .= $result;
        }
    }
    if ($top && $output =~ /\S/) {
        border;
        $output =~ s/^/<p>\n/;
        $output =~ s%\n(\s*)\z%\n</p>\n$1%;
    }
    $output;
}


############################################################################
# Page placement
############################################################################

# Given the name of the current file being processed, opens a .placement
# file if available and outputs the navigation links for that file.  If no
# .placement file is present, nothing is output.
sub placement {
    my $file = shift;

    # Grab placement information for links if we have it.
    if (open (PLACEMENT, '.placement')) {
        local $_;
        local $/ = "\n";
        my (%titles, @placement);
        while (<PLACEMENT>) {
            next if /^\s*$/;
            last if /---/;
            my ($page, $title) = split (' ', $_, 2);
            chomp $title;
            $titles{$page} = $title;
        }
        while (<PLACEMENT>) {
            if (/^$file\s/) {
                chomp;
                @placement = split;
                shift @placement;
                last;
            }
        }
        close PLACEMENT;
        unless (@placement) {
            die "$0: can't find placement for $file\n";
        }
        @placement = map { $_ eq '!' ? undef : $_ } @placement;

        my @text = ('Onward to', 'Back to', 'Return to');
        my $br = '';
        output "<p align=right>\n";
        for my $i (0..2) {
            next unless defined $placement[$i];
            my $href = '<a href="' . $placement[$i] . '">' .
                $titles{$placement[$i]} . '</a>';
            $href =~ s/^(<[^>]+>)the /the $1/;
            output $br, '    ', $text[$i], ' ', $href;
            $br = " <br>\n";
        }
        output "\n</p>\n\n<hr>\n\n";
    }
}

# Print out the signature file for pages in this directory, if present.
sub sign {
    if (open (SIG, '< .signature')) {
        local $/ = "\n";
        my @signature = <SIG>;
        chomp @signature;
        close SIG;
        output join ("\n    ", @signature);
        output " <br>\n    ";
    }
}


############################################################################
# Basic commands
############################################################################

sub align { 'align=center' }

sub do_cite   { '<cite>' . $_[1] . '</cite>' }
sub do_bold   { '<strong>' . $_[1] . '</strong>' }
sub do_emph   { '<em>' . $_[1] . '</em>' }
sub do_id     { $DOCID = $_[1]; output "<!-- $_[1] -->\n\n"; '' }
sub do_italic { '<i>' . $_[1] . '</i>' }
sub do_link   { '<a href="' . $_[1] . '">' . $_[2] . '</a>' }
sub do_rule   { border; output "<hr>\n\n"; '' }

sub do_desc {
    my ($format, $heading, $text) = @_;
    border ('desc', "<dl>\n", "</dl>\n");
    $text =~ s%\n\n\s*(\S)%\n</p>\n\n<p>$1%g;
    $text =~ s/\s*\n\n+$/\n/;
    output "<dt>$heading</dt>\n<dd><p>$text</p></dd>\n\n";
    '';
}

sub do_h {
    my ($level, $format, $text) = @_;
    border;
    if ($format && $format =~ s/b//) { $text =~ s/(\n\s*\S)/<br>$1/g }
    if ($format) {
        output "<h$level " . align ($format) . '>' . $text
            . "</h$level>\n\n";
    } else {
        output "<h$level>" . $text . "</h$level>\n\n";
    }
    '';
}

sub do_image {
    my ($format, $image, $text) = @_;
    my $size = lc html_imgsize ($image);
    if ($format) {
        "<img src=\"$image\" alt=\"$text\" $size " . align ($format) . '>';
    } else {
        "<img src=\"$image\" alt=\"$text\" $size>";
    }
}

sub do_quote {
    my ($format, $quote, $author, $cite) = @_;
    border;
    if ($format && $format =~ s/b//) {
        $quote =~ s/(\S *)(\n\s*\S)/$1<br>$2/g;
    }
    my $output = '<blockquote>';
    if ($format) {
        $output .= '<p ' . align ($format) . '>';
    } else {
        $output .= '<p>';
    }
    output $output . $quote . "</p><p align=center>\n";
    if ($cite) {
        output "    <strong>$author,\n    $cite";
    } else {
        output "    <strong>$author";
    }
    output "</strong>\n</p></blockquote>\n\n";
    '';
}

sub do_signature {
    border;
    output "<hr>\n\n";
    my $file = $FILE;
    $file =~ s/\.th$/.html/;
    placement $file;

    # Figure out the modified dates and print out the rest of the footer.
    my $modified = (split (' ', $DOCID))[3];
    if ($modified) {
        $modified =~ s{^(\d+)/(\d+)/(\d+)}{
            sprintf ("%d-%02d-%02d", $1, $2, $3)
        }e;
    } else {
        $modified = strftime ('%Y-%m-%d', gmtime ((stat $FILE)[9]));
    }
    my $spun = strftime ('%Y-%m-%d', gmtime);
    if ($modified eq $spun) {
        $modified = 'Last modified and spun ' . $modified;
    } else {
        $modified = "Last spun $spun from thread modified $modified";
    }
    output "<address>\n    ";
    sign;
    output "$modified\n</address>\n</body>\n</html>\n";
    '';
}

sub do_title {
    output "<html>\n<head>\n  <title>$_[1]</title>\n</head>\n\n<body>\n\n";
    '';
}

%commands = (cite      => [ 1, \&do_cite      ],
             bold      => [ 1, \&do_bold      ],
             desc      => [ 2, \&do_desc      ],
             emph      => [ 1, \&do_emph      ],
             id        => [ 1, \&do_id        ],
             image     => [ 2, \&do_image     ],
             italic    => [ 1, \&do_italic    ],
             link      => [ 2, \&do_link      ],
             quote     => [ 3, \&do_quote     ],
             rule      => [ 0, \&do_rule      ],
             signature => [ 0, \&do_signature ],
             title     => [ 1, \&do_title     ]);

for (1..7) { $commands{"h$_"} = [ 1, eval "sub { do_h ($_, \@_) }" ] }


############################################################################
# Interface
############################################################################

# This function is called, giving an input and an output file name, to spin
# HTML from thread.
sub spin {
    my ($thread, $output) = @_;
    $FILE = $thread;
    open (IN, $thread) or die "$0: can't open $thread: $!\n";
    open (OUT, "> $output") or die "$0: can't create $output: $!\n";
    $OUT = \*OUT;

    # Add our initial comment.
    my $version = (split (' ', $ID))[2];
    my $date = strftime ('%Y-%m-%d %T -0000', gmtime);
    output "<!-- Spun from $thread by spin $version on $date -->\n";

    # Parse the thread file a paragraph at a time (but pick up macro
    # contents that are continued across paragraphs.
    local $/ = '';
    local $_;
    while (<IN>) {
        my $open = tr/\[//;
        my $close = tr/\]//;
        while (!eof && $open > $close) {
            my $extra = <IN>;
            $open += ($extra =~ tr/\[//);
            $close += ($extra =~ tr/\]//);
            $_ .= $extra;
        }
        my $result = parse (escape ($_), 1);
        output $result unless ($result =~ /^\s*$/);
    }
    output '';
    close IN;
    close OUT;
}


############################################################################
# Per-file operations
############################################################################

# A wrapper around the faq2html script, used to handle .faq pointers in a
# tree being spun.  Adds the navigation links and the signature to the
# faq2html output.
sub faq2html {
    my ($source, $output) = @_;
    my @page = `faq2html $source`;
    open (OUT, "> $output") or die "$0: can't create $output: $!\n";
    $OUT = \*OUT;

    # Grab the first few lines of input, looking for a blurb.  Give up if we
    # encounter <html> first.
    my $blurb;
    local $_;
    while (defined ($_ = shift @page)) {
        last if /<html>/i;
        if (/<!--\s*(Converted.*)\s*-->/) { $blurb = $1; last }
        print OUT $_;
    }
    print OUT $_;

    # Snarf input and write it to output until we see </body>, which is our
    # signal to start adding things.  We just got very confused if </body>
    # was on the same line as <html>, so don't do that.
    print $OUT $_ while (defined ($_ = shift @page) && !m%</body>%i);

    # Print out our separator line and placement information, if any.
    print $OUT "\n<hr>\n\n";
    my $file = $output;
    $file =~ s%^.*/%%;
    placement $file;

    # Print out the signature and blurb.
    output "<address>\n    ";
    sign;
    output "$blurb\n</address>\n\n";

    # Finish with the faq2html output.
    print $OUT @page;
}

# This routine is called for every file in the source tree, and references
# the variables $SOURCE and $OUTPUT to find the roots of the source and
# output tree.  It decides what to do with each file, whether spinning it or
# copying it.  It's called from within File::Find and therefore uses the
# standard File::Find variables.
sub process_file {
    return if /^\./;
    $File::Find::prune = 1, return if $_ eq 'CVS';
    my $input = $File::Find::name;
    my $output = $input;
    $output =~ s/^\Q$SOURCE/$OUTPUT/ or die "$0: $input out of tree?\n";
    my $shortout = $output;
    $shortout =~ s/^\Q$OUTPUT/.../;
    if (-d && -d $output) {
        return;
    } elsif (-d && !-d $output) {
        if (-e $output) {
            die "$0: can't replace $output with a directory\n";
        } else {
            mkdir ($output, 0755) or die "$0: mkdir $output failed: $!\n";
        }
    } elsif (/.faq$/) {
        $output =~ s/\.faq$/.html/;
        $shortout =~ s/\.faq$/.html/;
        open (POINTER, $input) or die "$0: can't open $input: $!\n";
        my $master = <POINTER>;
        close POINTER;
        chomp $master;
        return if (-e $output && -M $master >= -M $output);
        print "Formatting $shortout\n";
        faq2html ($master, $output);
    } elsif (/\.th$/) {
        $output =~ s/\.th$/.html/;
        $shortout =~ s/\.th$/.html/;
        return if (-e $output && -M $_ >= -M $output);
        print "Spinning $shortout\n";
        spin ($_, $output);
    } elsif (!-e $output || -M $_ < -M $output) {
        print "Updating $shortout\n";
        copy ($_, $output)
            or die "$0: copy of $input to $output failed: $!\n";
    }
}


############################################################################
# Main routine
############################################################################

$| = 1;
$0 =~ s%.*/%%;

# Load overrides from the user's home directory, if applicable.
if (-r "$ENV{HOME}/.spinrc") { do "$ENV{HOME}/.spinrc" }

# Take the source tree and the output tree on the command line.
if (@ARGV != 2) { die "Usage: $0 <source> <output>\n" }
($SOURCE, $OUTPUT) = @ARGV;

# Traverse the input directory and generate output into the output
# directory.
$File::Find::dont_use_nlink = 1;
find (\&process_file, $SOURCE);
