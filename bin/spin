#!/usr/bin/perl -w
$ID = q$Id$;
#
# spin -- Translate thread (an HTML macro language) into HTML.
#
# Copyright 1999, 2000, 2001, 2002, 2003 by Russ Allbery <rra@stanford.edu>
#
# This program is free software; you may redistribute it and/or modify it
# under the same terms as Perl itself.

##############################################################################
# Modules and declarations
##############################################################################

require 5.005;

# The URL to the software page for all of my web page generation software.
$URL = 'http://www.eyrie.org/~eagle/software/web/';

use strict;
use subs qw(expand parse);
use vars qw($DOCID $FILE $FULLPATH $ID $OUTPUT %SITEDESCS %SITELINKS $SOURCE
            $SPACE @STATE $STYLES $URL %commands %macros %strings);

use Getopt::Long qw(GetOptions);
use Image::Size qw(html_imgsize);
use File::Copy qw(copy);
use File::Find qw(find);
use POSIX qw(strftime);
use Text::Balanced qw(extract_bracketed);

##############################################################################
# Output
##############################################################################

# Sends something to the output file.  Pull out any trailing space and stash
# it temporarily, and put any trailing space that we'd previously stashed into
# the output string after any close tags.  This gets spacing working properly
# around boundaries.
sub output {
    my $output = join ('', @_);
    if ($SPACE) {
        $output =~ s%^(\s*(?:</(?!body)[^>]+>\s*)*)%$1$SPACE%;
        $SPACE = '';
    }
    if ($output =~ s/\n(\s+)\z/\n/) { $SPACE = $1 }
    print OUT $output;
}

##############################################################################
# Basic parsing
##############################################################################

# Escapes &, <, and > characters found in a string.
sub escape { local $_ = shift; s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g; $_ }

# Undo HTML entity escaping.
sub unescape { local $_ = shift; s/&lt;/</g; s/&gt;/>/g; s/&amp;/&/g; $_ }

# Wrap something in paragraph markers, being careful to get newlines right.
# Special-case a paragraph consisting entirely of <span> by turning it into a
# <p> with the same class.
sub paragraph {
    my $text = shift;
    $text =~ s/^\n(\s*\n)*//;
    $text =~ s/(\S[ \t]*)\z/$1\n/;
    if ($text =~ m%^(\s*)<span(?!.*<span)([^>]*)>(.*)</span>(\s*)\z%s) {
        my ($lead, $class, $text, $trail) = ($1, $2, $3, $4);
        return "$lead<p$class>$text</p>$trail";
    } else {
        $text =~ s/^/<p>\n/;
        $text =~ s%(\n\s*)\z%\n</p>$1%;
        return $text;
    }
}

# Opens or closes a border of a continued structure.  Either takes the name of
# the state and its start and end tags, or takes no arguments to close all
# open states.
sub border {
    my ($border, $start, $end) = @_;
    my $output = '';
    if ($border) {
        if ($STATE[-1] eq 'BLOCK' || $STATE[-1][0] ne $border) {
            $output .= $start;
            push (@STATE, [ $border, $end ]);
        }
    } else {
        my $state;
        while (defined ($state = pop @STATE)) {
            last if $state eq 'BLOCK';
            $output .= $$state[1];
        }
        push (@STATE, 'BLOCK');
    }
    return $output;
}

# Marks the beginning of major block structure.  Within this structure,
# borders will only clear to the level of this structure.
sub border_start {
    push (@STATE, 'BLOCK');
}

# Clears a major block structure.
sub border_clear {
    my $output = border;
    pop @STATE;
    return $output;
}

# Extract some number of arguments from the front of the given string.  If the
# optional third argument is true, try to pull off a parenthesized formatting
# instruction first, returning it as the first result (or undef if it's not
# found).  If the count is -1, pull off as many arguments as we can find.
sub extract {
    my ($text, $count, $format) = @_;
    my (@result, $code);
    $text =~ s/\s*//;
    if ($format && $text =~ /^\(/) {
        ($result[0], $text) = extract_bracketed ($text, '()');
        $result[0] = substr ($result[0], 1, -1);
    } else {
        $result[0] = '';
    }
    if ($count >= 0) {
        for (1..$count) {
            ($result[$_], $text) = extract_bracketed ($text, '[]');
            if ($result[$_]) {
                $result[$_] = substr ($result[$_], 1, -1);
            } else {
                warn "$0:$FILE:$.: Can't find argument $_\n";
            }
        }
    } else {
        while ($text =~ /^\s*\[/) {
            my $result;
            ($result, $text) = extract_bracketed ($text, '[]');
            last unless $result;
            $result = substr ($result, 1, -1);
            push (@result, $result);
        }
    }
    unless ($format) { shift @result }
    (@result, $text);
}

# Process a macro.  Takes the number of arguments, the definition of the
# macro, a flag saying whether we're at a block level, and then the values of
# all the arguments.  Only straight substitution commands are allowed here, of
# course.
sub macro {
    my ($args, $definition, $block) = @_;
    $definition =~ s/\\(\d+)/($1 > $args) ? "\\$1" : $_[$1 + 2]/ge;
    parse ($definition, $block);
}

# Expand a given command into its representation.  This function is mutually
# recursive with parse.  Takes a third argument indicating whether this is a
# top-level element (if it is, and it doesn't generate its own container, it
# may have to be wrapped in <p>) and a fourth argument saying whether we're at
# the top level of the document.
sub expand {
    my ($command, $text, $block) = @_;
    if ($command eq '==') {
        my ($new, $args, $definition);
        ($new, $args, $definition, $text) = extract ($text, 3);
        $macros{$new} = [ $args, $definition ];
        return ('', $text);
    } elsif ($command eq '=') {
        my ($variable, $value);
        ($variable, $value, $text) = extract ($text, 2);
        $strings{$variable} = parse ($value);
        return ('', $text);
    } elsif ($command =~ s/^=//) {
        if (exists $strings{$command}) {
            return ($strings{$command}, $text);
        } else {
            warn "$0:$FILE:$.: unknown string $command\n";
            return ('', $text);
        }
    } elsif ($command eq '\\') {
        return ('\\', $text);
    } elsif (ref $macros{$command}) {
        my ($args, $definition) = @{ $macros{$command} };
        my @args;
        if ($args != 0) {
            @args = extract ($text, $args, 0);
            $text = pop @args;
        }
        my $block = $block && ($text !~ /\S/);
        return (macro ($args, $definition, $block, @args), $text);
    } else {
        if (!ref $commands{$command}) {
            warn "$0:$FILE:$.: bad command $command\n";
            return ('', $text);
        }
        my ($args, $handler) = @{ $commands{$command} };
        my ($blocktag, $result);
        if ($args == 0) {
            ($blocktag, $result) = &$handler ();
        } else {
            my @args = extract ($text, $args, 1);
            $text = pop @args;
            my $format = shift @args;
            ($blocktag, $result) = &$handler ($format, @args);
        }
        if ($block && !$blocktag && $text !~ /\S/) {
            return (border . paragraph ($result . $text), '');
        } else {
            return ($result, $text);
        }
    }
}

# Given a text string, check it for escape sequences.  If there are any,
# expand them, returning the final string after all expansions have been done.
# This function is mutually recursive with expand.  Takes one flag, saying
# whether we're at the block level.
sub parse {
    my ($text, $block) = @_;
    if (index ($text, '\\') == -1) {
        return $block ? (border . paragraph ($text)) : $text;
    }

    # Chop off everything up to the first backslash and save it in output.
    # Then grab the escape and figure out what to do with it.
    my $output = '';
    my $complex = 0;
    while ($text) {
        $text =~ s/^([^\\]+|\\([\w=]+|.))?//
            or die "$0:$FILE:$.: unable to parse at '"
                . substr ($text, 0, 20) . "'";
        my $command;
        if (index ($1, '\\') == -1) {
            my $string = $1;
            $output .= $string;
            $complex = 1 if ($string =~ /\S/);
        } else {
            $command = $2;
            my $result;
            my $block = $block && ($output !~ /\S/);
            ($result, $text) = expand ($command, $text, $block);
            $output .= $result;
        }
        if ($text =~ s/^\n(\s*)//) {
            $output .= "\n" if ($text || $complex);
            $output .= $1;
        }
    }
    return ($block && $complex) ? (border . paragraph ($output)) : $output;
}

##############################################################################
# Page footers
##############################################################################

# Read the sitemap file for a site and flesh out the %SITEDESCS and %SITELINKS
# hashes with information from that file.  The first holds a map of partial
# URLs to descriptions, and %SITELINKS map partial URLs to a list of other
# partial URLs (previous, next, and up).  The format of the sitemap file is
# one line per web page, with indentation showing the tree structure, and with
# each line formatted as a partial URL, a colon, and a page description.  If
# two pages at the same level aren't related, a line with three dashes should
# be put between them at the same indentation level.
sub read_sitemap {
    my $map = shift;

    # @indents holds a stack of indentation levels.  @parents is a matching
    # stack of parent URLs for each level of indentation, and @prev is a
    # matching stack of the previous page at each level of indentation.  If
    # $prev[0] is undef, there is no previous page at that level.
    my @indents = (0);
    my @parents = ('/');
    my @prev;
    open (MAP, $map) or return;
    local $_;
    while (<MAP>) {
        next if /^\s*\#/;
        if (/^( *)---$/) {
            my $indent = length ($1);
            while ($indents[0] > $indent) {
                shift @indents;
                shift @prev;
                shift @parents;
            }
            $prev[0] = undef;
            next;
        }
        my ($indent, $url, $desc) = /^( *)([^\s:]+):\s+(.+)$/;
        next unless defined $desc;
        $indent = length ($indent);
        if ($indent > $indents[0]) {
            unshift (@parents, $prev[0]);
            unshift (@indents, $indent);
            unshift (@prev, undef);
        }
        while ($indents[0] > $indent) {
            shift @indents;
            shift @prev;
            shift @parents;
        }
        $SITELINKS{$url} = [ $prev[0], undef, $parents[0] ];
        $SITELINKS{$prev[0]}[1] = $url if defined $prev[0];
        $prev[0] = $url;
        $SITEDESCS{$url} = $desc;
    }
    close MAP;
    $SITEDESCS{'/'} = 'the main page';
}

# Given the partial URL to the current page and the partial URL to another
# page, generate a relative URL between the two.
sub relative {
    my ($start, $end) = @_;
    my @start = split ('/', $start, -1);
    my @end = split ('/', $end, -1);
    while (@start && @end && $start[0] eq $end[0]) {
        shift @start;
        shift @end;
    }
    if (@start == 1 && @end == 1) {
        return ($end[0] ? $end[0] : './');
    } else {
        return ('../' x $#start) . join ('/', @end);
    }
}

# Given the name of the current file being processed, return the navigation
# links for that file.  Uses the global %SITEDESCS and %SITELINKS variables.
# If the partial URL isn't found in those variables, nothing is returned.
sub placement {
    my $file = shift;
    $file = $File::Find::dir . '/' . $file;
    $file =~ s%^\Q$SOURCE%%;
    $file =~ s%/index\.html$%/%;

    my $output = '';
    if ($SITELINKS{$file}) {
        my @links = @{ $SITELINKS{$file} };
        my @descs = map { defined ($_) ? $SITEDESCS{$_} : '' } @links;
        @links = map { defined ($_) ? relative ($file, $_) : undef } @links;

        # Swap the order to make next before previous.
        @links[0,1] = @links[1,0];
        @descs[0,1] = @descs[1,0];

        # Make the HTML for the footer.
        my @text = ('Onward to', 'Back to', 'Return to');
        my $br = '';
        $output .= qq(<p class="navigation">\n);
        for my $i (0..2) {
            next unless defined $links[$i];
            my $href = '<a href="' . $links[$i] . '">' . $descs[$i] . '</a>';
            $href =~ s/^(<[^>]+>)the /the $1/;
            $output .= $br . '    ' . $text[$i] . ' ' . $href;
            $br = "<br />\n";
        }
        $output .= "\n</p>\n\n";
    }
    return $output;
}

# Return the signature file for pages in this directory, if present.
sub sign {
    my $output = '';
    if (open (SIG, '< .signature')) {
        local $/ = "\n";
        my @signature = <SIG>;
        chomp @signature;
        close SIG;
        $output .= join ("\n    ", @signature);
        $output .= " <br />\n    ";
    }
    return $output;
}

# Returns the page footer, which consists of the navigation links, the regular
# signature, and the last modified date.  Takes as arguments the full path to
# the source file, the name of the destination file, the CVS Id of the source
# file if known, the template to use if the modification and current dates are
# the same, and the temlate to use if they're different.  The templates will
# have the strings %MOD% and %NOW% replaced by the appropriate dates and %URL%
# with the URL to my HTML generation software..
sub footer {
    my ($source, $file, $id, @templates) = @_;
    my $output = placement $file;
    $output .= "<address>\n    " . sign;

    # Figure out the modified dates.
    my $modified = (split (' ', $id || ''))[3];
    if ($modified && $modified =~ m%^(\d+)/(\d+)/(\d+)%) {
        $modified = sprintf ("%d-%02d-%02d", $1, $2, $3);
    } else {
        $modified = strftime ('%Y-%m-%d', gmtime ((stat $source)[9]));
    }
    my $now = strftime ('%Y-%m-%d', gmtime);

    # Determine which template to use and substitute in the appropriate times.
    my $template = ($modified eq $now) ? $templates[0] : $templates[1];
    if ($template) {
        for ($template) {
            s/%MOD%/$modified/g;
            s/%NOW%/$now/g;
            s/%URL%/$URL/g;
        }
        $output .= "$template\n";
    }
    $output .= "</address>\n";
    return $output;
}

##############################################################################
# Supporting functions
##############################################################################

# Given the format argument to a command, return the class or id attribute
# that should be used preceeded by a space, or an empty string if none should
# be used.
sub format_string {
    my $format = shift;
    if ($format) {
        if ($format =~ s/^\#//) {
            return ' id="' . $format . '"';
        } else {
            return ' class="' . $format . '"';
        }
    } else {
        return '';
    }
}

# Splits a block of text apart at paired newlines so that it can be reparsed
# in paragraphs, but combines a paragraph with the next one if it has an
# unbalanced number of open brackets.  Used by containiners like \block that
# can contain multiple paragraphs.
sub split_paragraphs {
    my $text = shift;
    my @paragraphs;
    while ($text && $text =~ s/^(.*?(?:\n\n+|\s*\z))//s) {
        my $paragraph = $1;
        my $open = ($paragraph =~ tr/\[//);
        my $close = ($paragraph =~ tr/\]//);
        while ($text && $open > $close) {
            $text =~ s/^(.*?(?:\n\n+|\s*\z))//s;
            my $extra = $1;
            $open += ($extra =~ tr/\[//);
            $close += ($extra =~ tr/\]//);
            $paragraph .= $extra;
        }
        push (@paragraphs, $paragraph);
    }
    return @paragraphs;
}

# A simple block element.  Takes the name of the tag, an initial string to be
# prepended verbatim, the format, and the text.  Handles splitting the
# argument on paragraph boundaries and surrounding things properly with the
# tag.
sub block {
    my ($tag, $border, $format, $text) = @_;
    my $output;
    if ($format eq 'packed') {
        $output = parse ($text, 0);
    } else {
        border_start;
        $output = join ('', map { parse ($_, 1) } split_paragraphs ($text));
        $output .= border_clear;
    }
    $output = $border . "<$tag" . format_string ($format) . '>' . $output;
    $output =~ s%\s*\z%</$tag>\n%;
    return (1, $output);
}

# A heading.  Handles formats of #something specially by adding an <a name>
# tag inside the heading tag to make it a valid target for internal links even
# in old browsers.
sub heading {
    my ($level, $format, $text) = @_;
    my $output = border;
    if ($format && $format =~ /^\#/) {
        my $tag = $format;
        $tag =~ s/^\#//;
        $text = qq(<a name="$tag">$text</a>);
    }
    $output .= "<h$level" . format_string ($format) . '>';
    $output .= parse ($text);
    $output =~ s/\n\z//;
    $output .= "</h$level>\n";
    return (1, $output);
}

# A simple inline element.  Takes the name of the tag, the format, and the
# body and returns the appropriate list of block level and HTML.
sub inline {
    my ($tag, $format, $text) = @_;
    my $output = "<$tag" . format_string ($format) . '>';
    $output .= parse ($text) . "</$tag>";
    return (0, $output);
}

# Enclose some text in another tag.  The one special thing that we do is if
# the enclosed text is entirely enclosed in <span> tags, we pull the options
# of the <span> out and instead apply them to the parent tag.  Takes the tag
# and the text to enclose.
sub enclose {
    my ($tag, $text) = @_;
    my $close = $tag;
    $close =~ s/ .*//;
    if ($text =~ m%^(\s*)<span(?!.*<span)([^>]*)>(.*)</span>(\s*)\z%s) {
        my ($lead, $class, $text, $trail) = ($1, $2, $3, $4);
        return "$lead<$tag$class>$text</$close>$trail";
    } else {
        return "<$tag>$text</$close>";
    }
}

##############################################################################
# Commands
##############################################################################

# Basic inline commands.
sub do_break  { (0, '<br />') }
sub do_cite   { inline ('cite', @_) }
sub do_class  { inline ('span', @_) }
sub do_code   { inline ('code', @_) }
sub do_bold   { inline ('strong', @_) }
sub do_emph   { inline ('em', @_) }
sub do_italic { inline ('i', @_) }
sub do_rule   { return (1, border . "<hr />\n") }

# Basic block commands.
sub do_block  { block ('blockquote', '', @_) }
sub do_bullet { block ('li', border ('bullet', "<ul>\n", "</ul>\n"), @_) }
sub do_number { block ('li', border ('number', "<ol>\n", "</ol>\n"), @_) }

# A description list entry, which takes the heading and the body as arguments.
sub do_desc {
    my ($format, $heading, $text) = @_;
    my $initial = border ('desc', "<dl>\n", "</dl>\n");
    $initial .= '<dt>' . parse ($heading) . "</dt>\n";
    return block ('dd', $initial, $format, $text);
}

# An HTML entity.  Check for and handle numeric entities properly.
sub do_entity {
    my ($format, $char) = @_;
    $char = parse ($char);
    if ($char =~ /^\d+$/) {
        return (0, '&#' . $char . ';');
    } else {
        return (0, '&' . $char . ';');
    }
}

# Generates the page heading at the top of the document.  Takes as arguments
# the page title and the page style.  This is where the XHTML declarations
# come from.
sub do_heading {
    my ($format, $title, $style) = @_;
    my $output = qq(<?xml version="1.0" encoding="iso-8859-1"?>\n);
    $output .= qq(<!DOCTYPE html\n);
    $output .= qq(    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"\n);
    $output .= qq(    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">\n);
    $output .= qq(\n<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en");
    $output .= qq( lang="en">\n);
    $output .= qq(<head>\n  <title>$title</title>\n);
    $output .= qq(  <meta http-equiv="Content-Type");
    $output .= qq( content="text/html; charset=iso-8859-1" />\n);
    if ($style) {
        $style .= '.css';
        $style = $STYLES . $style if $STYLES;
        $output .= qq(  <link rel="stylesheet" href="$style");
        $output .= qq( type="text/css" />\n);
    }
    $output .= "</head>\n\n";
    my $version = (split (' ', $ID))[2];
    my $date = strftime ('%Y-%m-%d %T -0000', gmtime);
    $output .= '<!-- Spun from ' . ($FILE eq '-' ? 'stdin' : $FILE)
        . " by spin $version on $date -->\n";
    $output .= "<!-- $DOCID -->\n" if $DOCID;
    $output .= "\n<body>\n";
    return (1, $output);
}

# Used to save the RCS Id for the document.  Doesn't actually output anything
# (the identifier is later used in do_heading).
sub do_id {
    my ($format, $id) = @_;
    $DOCID = $id;
    return (1, '');
}

# Include an image.  The size is added to the HTML tag automatically.  Takes
# the relative path to the image and the alt text.
sub do_image {
    my ($format, $image, $text) = @_;
    $image = parse ($image);
    $text = parse ($text);
    my $size = lc html_imgsize ($image);
    my $output = qq(<img src="$image" alt="$text" $size);
    $output .= format_string ($format) . " />\n";
    return (1, $output);
}

# A link to a URL or partial URL.
sub do_link {
    my ($format, $url, $text) = @_;
    my $output = '<a href="' . parse ($url) . '"';
    $output .= format_string ($format) . '>' . parse ($text) . '</a>';
    return (0, $output);
}

# Preformatted text, the same as the HTML tag.
sub do_pre {
    my ($format, $text) = @_;
    my $output = border;
    $output .= '<pre' . format_string ($format) . '>' . parse ($text);
    $output .= "</pre>\n";
    return (1, $output);
}

# Used for the leading quotes that I have on many of my pages.  Takes the
# quote, the author, and the citation; the citation may be empty.  If the
# format is "broken", adds line breaks at the end of each line.
sub do_quote {
    my ($format, $quote, $author, $cite) = @_;
    my $output = border . '<blockquote class="quote">';
    border_start;
    $quote = join ('', map { parse ($_, 1) } split_paragraphs ($quote));
    $quote .= border_clear;
    if ($format && $format eq 'broken') {
        $quote =~ s%(\S *)(\n\s*(?!</p>)\S)%$1<br />$2%g;
        $quote =~ s%\n<br />%\n%g;
        $quote =~ s%<p><br />%<p>%g;
    }
    $quote =~ s/\n+$//;
    if ($format) {
        my $class = format_string ($format);
        $quote =~ s/<p>/<p$class>/g;
    }
    $output .= $quote;
    if ($author) {
        $author = parse ($author);
        $output .= qq(<p class="attribution">\n);
        if ($cite) {
            $cite = parse ($cite);
            $output .= "    $author,\n    $cite\n";
        } else {
            $output .= "    $author\n";
        }
        $output .= "</p>";
    } else {
        $output .= "\n";
    }
    $output .= "</blockquote>\n";
    return (1, $output);
}

# Used to end each page, this adds the navigation links and my standard
# address block.
sub do_signature {
    my $output = border;
    if ($FILE eq '-') {
        $output .= "</body>\n</html>\n";
        return (1, $output);
    }
    my $file = $FILE;
    $file =~ s/\.th$/.html/;
    my $link = '<a href="%URL%">spun</a>';
    $output .= footer ($FILE, $file, $DOCID,
                       "Last modified and\n    $link %MOD%",
                       "Last $link\n    %NOW% from thread modified %MOD%");
    $output .= "</body>\n</html>\n";
    return (1, $output);
}

# Start a table.  Takes any additional HTML attributes to set for the table
# (this is ugly, but <table> takes so many attributes for which there is no
# style sheet equivalent that it's unavoidable) and the body of the table
# (which should consist of \tablehead and \tablerow lines).
sub do_table {
    my ($format, $options, $body) = @_;
    my $tag = $options ? "table $options" : 'table';
    return block ($tag, '', $format, $body);
}

# A heading of a table.  Takes the contents of the cells in that heading.
sub do_tablehead {
    my ($format, @cells) = @_;
    my $output = '  <tr' . format_string ($format) . ">\n";
    for (@cells) {
        $output .= '    ' . enclose ('th', parse ($_)) . "\n";
    }
    $output .= "  </tr>\n";
    return (1, $output);
}

# A data line of a table.  Takes the contents of the cells in that row.
sub do_tablerow {
    my ($format, @cells) = @_;
    my $output = '  <tr' . format_string ($format) . ">\n";
    for (@cells) {
        $output .= '    ' . enclose ('td', parse ($_)) . "\n";
    }
    $output .= "  </tr>\n";
    return (1, $output);
}

# Output HTML text completely verbatim.
sub do_verbatim {
    my ($format, $text) = @_;
    $text = unescape ($text);
    return (1, $output);
}

# The table of available commands.  First column is the number of arguments,
# second column is the handler, and the third column is whether this is its
# own top-level element or whether it needs to be wrapped in <p> tags.  A
# count of -1 means pull off as many arguments as we can find.
%commands = (block      => [  1, \&do_block      ],
             break      => [  0, \&do_break      ],
             bullet     => [  1, \&do_bullet     ],
             class      => [  1, \&do_class      ],
             cite       => [  1, \&do_cite       ],
             code       => [  1, \&do_code       ],
             bold       => [  1, \&do_bold       ],
             desc       => [  2, \&do_desc       ],
             emph       => [  1, \&do_emph       ],
             entity     => [  1, \&do_entity     ],
             heading    => [  2, \&do_heading    ],
             id         => [  1, \&do_id         ],
             image      => [  2, \&do_image      ],
             italic     => [  1, \&do_italic     ],
             link       => [  2, \&do_link       ],
             number     => [  1, \&do_number     ],
             pre        => [  1, \&do_pre        ],
             quote      => [  3, \&do_quote      ],
             rule       => [  0, \&do_rule       ],
             signature  => [  0, \&do_signature  ],
             table      => [  2, \&do_table      ],
             tablehead  => [ -1, \&do_tablehead  ],
             tablerow   => [ -1, \&do_tablerow   ],
             verbatim   => [  1, \&do_verbatim   ]);

# Add handlers for all the headings.
for (1..6) { $commands{"h$_"} = [ 1, eval "sub { heading ($_, \@_) }" ] }

##############################################################################
# Interface
##############################################################################

# This function is called, giving an input and an output file name, to spin
# HTML from thread.
sub spin {
    my ($thread, $output) = @_;
    $FILE = $thread;
    open (IN, $thread) or die "$0: can't open $thread: $!\n";
    open (OUT, "> $output") or die "$0: can't create $output: $!\n";
    $SPACE = '';

    # Parse the thread file a paragraph at a time (but pick up macro contents
    # that are continued across paragraphs.
    local $/ = '';
    local $_;
    border_start;
    while (<IN>) {
        my $open = tr/\[//;
        my $close = tr/\]//;
        while (!eof && $open > $close) {
            my $extra = <IN>;
            $open += ($extra =~ tr/\[//);
            $close += ($extra =~ tr/\]//);
            $_ .= $extra;
        }
        my $result = parse (escape ($_), 1, 1);
        output $result unless ($result =~ /^\s*$/);
    }
    print OUT border_clear, $SPACE;
    close IN;
    close OUT;
}

##############################################################################
# External converters
##############################################################################

# Given the command to run to generate the page, the file to save the output
# in, and an anonymous sub that takes three arguments, the first being the
# captured blurb, the second being the document ID if found, and the third
# being the base name of the output file, and prints out a last modified line,
# handle a call to an external converter.
sub run_converter {
    my ($command, $output, $footer) = @_;
    my @page = `$command`;
    if ($? != 0) {
        $command =~ s/ .*//;
        die "$0: command failed with exit status ", ($? >> 8), "\n";
    }
    open (OUT, "> $output") or die "$0: can't create $output: $!\n";

    # Grab the first few lines of input, looking for a blurb and Id string.
    # Give up if we encounter <html> first.
    my ($blurb, $docid);
    local $_;
    while (defined ($_ = shift @page)) {
        last if /<body/i;
        if (/<!--\s*(\$Id.*?)\s*-->/) {
            $docid = $1;
        }
        if (/<!--\s*((?:Generated|Converted).*?)\s*-->/) {
            $blurb = $1;
            $blurb =~ s/ \d\d:\d\d:\d\d -0000//;
            $blurb =~ s/ \(\d{4}-\d\d-\d\d\)//;
        }
        print OUT $_;
    }
    print OUT $_ if defined;

    # Snarf input and write it to output until we see </body>, which is our
    # signal to start adding things.  We just got very confused if </body> was
    # on the same line as <html>, so don't do that.
    print OUT $_ while (defined ($_ = shift @page) && !m%</body>%i);

    # Add the footer and finish with the output.
    my $file = $output;
    $file =~ s%^.*/%%;
    print OUT &$footer ($blurb, $docid, $file);
    print OUT $_, @page;
    close OUT;
}

# A wrapper around the cl2xhtml script, used to handle .changelog pointers in
# a tree being spun.  Adds the navigation links and the signature to the
# cl2xhtml output.
sub cl2xhtml {
    my ($source, $output, $options, $style) = @_;
    $style = $STYLES . 'changelog.css' unless $style;
    my $command = "cl2xhtml $options -s $style $source";
    my $footer = sub {
        my ($blurb, $id, $file) = @_;
        $blurb =~ s%cl2xhtml%\n<a href="$URL">cl2xhtml</a>% if $blurb;
        footer ($source, $file, $id, $blurb, $blurb);
    };
    run_converter ($command, $output, $footer);
}

# A wrapper around the cvs2xhtml script, used to handle .log pointers in a
# tree being spun.  Adds the navigation links and the signature to the
# cvs2xhtml output.
sub cvs2xhtml {
    my ($source, $output, $options, $style) = @_;
    my $dir = $source;
    $dir =~ s%/+[^/]+$%%;
    my $name = $source;
    $name =~ s%^.*/%%;
    $options .= " -n $name" unless $options =~ /-n /;
    $style = $STYLES . 'cvs.css' unless $style;
    $options .= " -s $style";
    my $command = "(cd $dir && cvs log $source) | cvs2xhtml $options";
    my $footer = sub {
        my ($blurb, $id, $file) = @_;
        $blurb =~ s%cvs2xhtml%\n<a href="$URL">cvs2xhtml</a>% if $blurb;
        footer ($source, $file, $id, $blurb, $blurb);
    };
    run_converter ($command, $output, $footer);
}

# A wrapper around the faq2html script, used to handle .faq pointers in a tree
# being spun.  Adds the navigation links and the signature to the faq2html
# output.
sub faq2html {
    my ($source, $output, $options, $style) = @_;
    $style = $STYLES . 'faq.css' unless $style;
    my $command = "faq2html $options -s $style $source";
    my $footer = sub {
        my ($blurb, $id, $file) = @_;
        $blurb =~ s%faq2html%\n<a href="$URL">faq2html</a>%;
        footer ($source, $file, $id, $blurb, $blurb);
    };
    run_converter ($command, $output, $footer);
}

# A wrapper around pod2thread and spin -f, used to handle .pod pointers in a
# tree being spun.  Adds the navigation links and the signature to the output.
sub pod2html {
    my ($source, $output, $options, $style) = @_;
    $options = '-n' unless $options;
    my $styles = ($STYLES ? " -s $STYLES" : '');
    $style = 'pod' unless $style;
    $options .= " -s $style";
    my $command = "pod2thread $options $source | $FULLPATH -f$styles";
    my $footer = sub {
        my ($blurb, $id, $file) = @_;
        my $link = '<a href="%URL%">spun</a>';
        footer ($source, $file, $id,
                "Last modified and\n    $link %MOD%",
                "Last $link\n    %NOW% from POD modified %MOD%");
    };
    run_converter ($command, $output, $footer);
}

##############################################################################
# Per-file operations
##############################################################################

# Given a pointer file, read the master file and any options from that file,
# returning them as a list with the newlines chomped off.
sub read_pointer {
    my $file = shift;
    open (POINTER, $file) or die "$0: can't open $file: $!\n";
    my $master = <POINTER>;
    my $options = <POINTER>;
    my $style = <POINTER>;
    close POINTER;
    die "$0: no master file specified in $file" unless $master;
    chomp $master;
    chomp $options if defined $options;
    chomp $style if defined $style;
    $options ||= '';
    return ($master, $options, $style);
}

# This routine is called for every file in the source tree, and references the
# variables $SOURCE and $OUTPUT to find the roots of the source and output
# tree.  It decides what to do with each file, whether spinning it or copying
# it.  It's called from within File::Find and therefore uses the standard
# File::Find variables.
sub process_file {
    return if /^\./;
    $File::Find::prune = 1, return if ($_ eq 'CVS' || $_ eq 'Makefile');
    my $input = $File::Find::name;
    my $output = $input;
    $output =~ s/^\Q$SOURCE/$OUTPUT/ or die "$0: $input out of tree?\n";
    my $shortout = $output;
    $shortout =~ s/^\Q$OUTPUT/.../;

    # Conversion rules for pointers.  The key is the extension, the first
    # value is the name of the command for the purposes of output, and the
    # second is the sub to run.
    my %rules = (changelog => [ 'cl2xhtml',   \&cl2xhtml  ],
                 faq       => [ 'faq2html',   \&faq2html  ],
                 log       => [ 'cvs2xhtml',  \&cvs2xhtml ],
                 rpod      => [ 'pod2thread', \&pod2html  ]);

    # Figure out what to do with the input.
    if (-d) {
        return if -d $output;
        if (-e $output) {
            die "$0: can't replace $output with a directory\n";
        } else {
            mkdir ($output, 0755) or die "$0: mkdir $output failed: $!\n";
        }
    } elsif (/\.th$/) {
        $output =~ s/\.th$/.html/;
        $shortout =~ s/\.th$/.html/;
        return if (-e $output && -M $_ >= -M $output);
        print "Spinning $shortout\n";
        spin ($_, $output);
    } else {
        my ($extension) = (/\.([^.]+)$/);
        if ($extension && $rules{$extension}) {
            my ($name, $sub) = @{ $rules{$extension} };
            $output =~ s/\.\Q$extension\E$/.html/;
            $shortout =~ s/\.\Q$extension\E$/.html/;
            my ($file, $options, $style) = read_pointer ($input);
            return if (-e $output && -M $file >= -M $output);
            print "Running $name for $shortout\n";
            &$sub ($file, $output, $options, $style);
        } elsif (!-e $output || -M $_ < -M $output) {
            print "Updating $shortout\n";
            copy ($_, $output)
                or die "$0: copy of $input to $output failed: $!\n";
        }
    }
}

##############################################################################
# Main routine
##############################################################################

$| = 1;
$FULLPATH = $0;
$0 =~ s%.*/%%;

# Parse command-line options.
my ($help, $version, $filter, $overrides);
$STYLES = '';
Getopt::Long::config ('bundling');
GetOptions ('filter|f'      => \$filter,
            'help|h'        => \$help,
            'overrides|o=s' => \$overrides,
            'style-url|s=s' => \$STYLES,
            'version|v'     => \$version) or exit 1;
if ($help) {
    print "Feeding myself to perldoc, please wait....\n";
    exec ('perldoc', '-t', $FULLPATH);
} elsif ($version) {
    my $version = join (' ', (split (' ', $ID))[1..3]);
    $version =~ s/,v\b//;
    $version =~ s/(\S+)$/($1)/;
    $version =~ tr%/%-%;
    print $version, "\n";
    exit;
}
$STYLES =~ s%/*$%/% if $STYLES;

# Load overrides from the specified file, if desired.
if ($overrides) { do "$overrides" }

# The arguments depend on whether -f is given.  If it is, just filter stdin to
# stdout; otherwise, take the input tree and the output tree on the command
# line and process the input into the output.
if ($filter) {
    if (@ARGV) { die "Usage: $0 -f\n" }
    spin ('-', '-');
} else {
    if (@ARGV != 2) { die "Usage: $0 <source> <output>\n" }
    ($SOURCE, $OUTPUT) = @ARGV;
    read_sitemap ("$SOURCE/.sitemap");
    $File::Find::dont_use_nlink = 1;
    find (\&process_file, $SOURCE);
}

##############################################################################
# Documentation
##############################################################################

=head1 NAME

spin - Translate thread, an HTML macro language, into XHTML

=head1 SYNOPSIS

spin [B<-hv>] [B<-s> I<url>] [B<-o> I<overrides>] I<source> I<output>

spin [B<-s> I<url>] [B<-o> I<overrides>] B<-f>

=head1 REQUIREMENTS

Perl 5.005 or later and the Image::Size and Text::Balanced modules.  Also
expects to find B<faq2html>, B<cvs2xhtml>, and B<cl2xhtml> to convert
certain types of files.

=head1 DESCRIPTION

B<spin> implements a fairly simple macro language that expands out into
XHTML, as well as serving as a tool to maintain a set of web pages, updating
a staging area with the latest versions, converting pages written in the
macro language (named "thread"), and running B<faq2html> where directed.

When invoked with the B<-f> option, B<spin> works in filter mode, reading
thread from stdin and writing the converted output to stdout.  Some
features, such as appending a signature or navigation links, are disabled in
this mode.

Otherwise, for each file in the directory I<source>, recursively through the
directory structure, it is either copied verbatim into the same relative
path under I<output> or converted to HTML with the HTML output put under
I<output> with the same file name but with the extension changed to
C<.html>.  Missing directories are created.  Files that end in C<.th> are
assumed to be in thread and are turned into HTML.

Files that end in various other extensions are taken to be instructions to
run an external converter on a file.  The first line of such a pointer file
should be the path to the source file, the second line any arguments to the
converter, and the third line the style sheet to use if not the default.
Which converter to run is based on the extension of the file as follows:

    .changelog  cl2xhtml
    .faq        faq2html
    .log        cvs log <file> | cvs2xhtml
    .rpod       pod2thread <file> | spin -f

All other files not beginning with a period are copied as-is, except that
files or directories named C<CVS> or C<Makefile> are ignored.

The exact details of the macro language are as yet not documented.  The
basic format, however, is that macro invocations start with C<\>, take an
optional initial argument specifying the class (in the style sheet sense,
resulting in a class attribute in the XHTML to which a style sheet can
refer) enclosed in parentheses, and then some number of arguments enclosed
in square brackets.  Any amount of space can separate the macro name from
the class argument or regular arguments, or the arguments from each other,
and that whitesepace is ignored.

In addition, a new macro can be defined using syntax like:

    \==[name] [arguments] [definition]

where name is the name of the macro, arguments is the number of arguments
that it takes, and definition is the definition of the macro, in which \1 is
replaced by the first argument, \2 by the second argument, and so forth.

Similarly, strings can be defined with:

    \=[name] [value]

and then later referred to in the page with \=name.  This is useful for
things like URLs for links, so that they're all collected at the top of the
page for easy updating.

Paragraphs can be left without markup and will automatically be wrapped in
HTML <p> tags.  The content of macros can span paragraphs.  Macros can be
nested arbitrarily.

Each page should begin with an \id macro containing an RCS Id string, and
then a \header macro specifying the page title and style sheet; this will
set up the proper XHTML headers.  Each page should also end with \signature,
which will append the navigation links and an address block.

B<spin> looks for a file named F<.sitemap> at the top of the I<source>
directory and reads it for navigation information to generate the navigation
links at the bottom of each page.  The format of this file is one line per
web page, with indentation showing the tree structure, and with each line
formatted as a partial URL, a colon, and a page description.  If two pages
at the same level aren't related, a line with three dashes should be put
between them at the same indentation level.  The partial URLs should start
with / representing the top of the hierarchy (the I<source> directory), but
all generated links will be relative.

B<spin> also looks for a file named F<.signature> in the same directory as a
thread file and uses its contents as the basis of the <address> block at the
end of the XHTML page.  The contents will be surrounded by an <address> tag
and added to the end will be information about when the page was last
modified and generated.

=head1 OPTIONS

=over 4

=item B<-f>, B<--filter>

Run B<spin> in filter mode rather than converting a whole tree of files.
Thread source is read from stdin and the XHTML output is written to stdout.
The signature and navigation links are disabled.

=item B<-h>, B<--help>

Print out this documentation (which is done simply by feeding the script to
C<perldoc -t>).

=item B<-o> I<overrides>, B<--overrides>=I<overrides>

Load the I<overrides> file using the Perl do command.  This file should
contain Perl code that overrides or adds to the Perl code that's part of
B<spin>.  It can be used to define new commands or change the behavior of
existing commands.

=item B<-s> I<url>, B<--style-url>=I<url>

The base URL for style sheets.  All style sheets specified in \heading
commands will be considered to be relative to this URL and this URL will be
prepended to them (otherwise, they'll be referred to as if they're in the
same directory as the generated file).  This will similarly be used as the
base URL to style sheets for the output of B<cl2xhtml>, B<cvs2xhtml>, and
B<faq2html>.

=item B<-v>, B<--version>

Print out the version of B<spin> and exit.

=back

=head1 BUGS

Currently, the style sheets for B<cl2xhtml>, B<cvs2xhtml>, B<faq2html>, and
B<pod2thread> are hard-coded into this program to fit my web pages.  This
makes this program awkward for others to use, since the style sheet has to
be specified in every pointer file if they're using different names.

This documentation is woefully incomplete; there should really be a
description of all of the pre-defined macros.

=head1 NOTES

The proper <link> tags representing the page hierarchy should really be
added to the header for the benefit of clients that can use them for
navigation information.

=head1 SEE ALSO

cl2xhtml(1), cvs2xhtml(1), faq2html(1), pod2thread(1)

The XHTML 1.0 standard at L<http://www.w3.org/TR/xhtml1/>.

Current versions of this program are available from my web tools page at
L<http://www.eyrie.org/~eagle/software/web/>, as are copies of all of the
above-mentioned programs.

=head1 AUTHOR

Russ Allbery <rra@stanford.edu>

=head1 COPYRIGHT AND LICENSE

Copyright 1999, 2000, 2001, 2002, 2003 by Russ Allbery <rra@stanford.edu>.

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.

=cut
