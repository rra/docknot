#!/usr/bin/perl -w
our $ID = q$Id$;
#
# spin-changes -- Translate a changes file to RSS and thread.
#
# Copyright 2008 Russ Allbery <rra@stanford.edu>
#
# This program is free software; you may redistribute it and/or modify it
# under the same terms as Perl itself.

##############################################################################
# Modules and declarations
##############################################################################

require 5.006;

use strict;
use Date::Parse qw(str2time);
use Getopt::Long qw(GetOptions);
use POSIX qw(strftime);

##############################################################################
# Utility functions
##############################################################################

# Returns the intersection of two arrays as a list.
sub intersect {
    my ($a, $b) = @_;
    my %a = map { $_ => 1 } @$a;
    return grep { $a{$_} } @$b;
}

# Construct an absolute URL from a relative URL and a base URL.
sub absolute_url {
    my ($url, $base) = @_;
    $base =~ s,[^/]+$,,;
    if ($url =~ /^https?:/) {
        return $url;
    } elsif ($url =~ m,^/,) {
        $base =~ s,^(https?://[^/]+).*,$1,;
        return "$base$url";
    } else {
        while ($url =~ s,^\.\./+,,) {
            $base =~ s,[^/]+/+$,,;
        }
        return "$base$url";
    }
}

# Construct a relative URL from an absolute URL and a base URL.
sub relative_url {
    my ($url, $base) = @_;
    return $url unless $base;
    $base =~ s,^(https?://[^/]+/)/*,,;
    my $host = $1;
    if (!$host || index ($url, $host) != 0) {
        return $url;
    }
    $url =~ s,^\Q$host\E/*,,;
    my @base = split (m,/+,, $base);
    while ($url and @base) {
        my $segment = shift @base;
        unless ($url =~ s,^\Q$segment\E/*,,) {
            return ('../' x (@base + 1)) . $url;
        }
    }
    return ('../' x @base) . $url;
}

##############################################################################
# Parsing
##############################################################################

# Parse a change file.  Save the metadata into the provided hash reference and
# the changes into the provided array reference.  Each element of the array
# will be a hash with keys title, date, link, and description.
sub parse_changes {
    my ($file, $metadata, $changes) = @_;
    open (CHANGES, '<', $file) or die "$0: cannot open $file: $!\n";
    local $_;
    my ($last, @blocks);
    push (@blocks, {});
    my $current = $blocks[0];
    while (<CHANGES>) {
        if (/^\s*$/) {
            push (@blocks, {});
            $current = $blocks[$#blocks];
            undef $last;
        } elsif (/^(\S+):[ \t]+(.+)/) {
            my ($key, $value) = ($1, $2);
            die "$0: cannot parse $file at line $.\n" unless $value;
            $value =~ s/\s+$//;
            $last = lc $key;
            $current->{$last} = $value;
        } elsif (/^(\S+):/) {
            $last = lc $1;
            $current->{$last} ||= '';
        } elsif (/^\s/) {
            die "$0: cannot parse $file at line $.\n" unless $last;
            my $value = $_;
            $value =~ s/^\s//;
            $value = "\n" if $value =~ /^\.\s*\n/;
            if ($current->{$last} and $current->{$last} !~ /\n\z/) {
                $current->{$last} .= "\n";
            }
            $current->{$last} .= $value;
        }
    }
    close CHANGES;
    pop @blocks unless $last;
    %$metadata = %{ shift @blocks };
    my %guids;
    for my $block (@blocks) {
        $block->{date} = str2time ($block->{date})
            or die "$0: cannot parse date $block->{date}\n";
        if ($block->{link} && $block->{link} !~ /^http/) {
            $block->{link} = $metadata->{base} . $block->{link};
        }
        unless ($block->{guid}) {
            my $guid;
            if ($block->{journal} || $block->{review}) {
                $guid = $block->{link};
            } else {
                $guid = $block->{date};
            }
            die "$0: duplicate GUID for entry $guid\n" if $guids{$guid};
            $block->{guid} = $guid;
        }
        if ($block->{tags}) {
            $block->{tags} = [ split (' ', $block->{tags}) ];
        } else {
            $block->{tags} = [];
        }
        push (@{ $block->{tags} }, 'review') if $block->{review};
    }
    @$changes = @blocks;
}

##############################################################################
# RSS output
##############################################################################

# Escape a string for XML.
sub xml_escape {
    my ($string) = @_;
    $string =~ s/&/&amp;/g;
    $string =~ s/</&lt;/g;
    $string =~ s/>/&gt;/g;
    return $string;
}

# Format a journal post into HTML for inclusion in an RSS feed.
sub rss_journal {
    my ($file) = @_;
    my @page = `spin '$file'`;
    if ($? != 0) {
        die "$0: spin of $file failed with status ", ($? >> 8), "\n";
    }
    shift @page while (@page and $page[0] !~ /<h1>/);
    shift @page;
    shift @page while (@page and $page[0] =~ /^\s*$/);
    pop @page while (@page and $page[$#page] !~ /<p class=\"date\">/);
    pop @page;
    pop @page while (@page and $page[$#page] =~ /^\s*$/);
    return '<![CDATA[' . join ('', @page) . "]]>\n";
}

# Format a review into HTML for inclusion in an RSS feed.  Takes the path to
# the review thread file and the metadata for this feed.
sub rss_review {
    my ($file, $metadata) = @_;
    my $dir = $file;
    $dir =~ s%/+[^/]*$%%;
    my $class = ($dir =~ /magazines/) ? 'magazines' : 'books';
    my $base = $metadata->{base} . ($metadata->{base} =~ m%/$% ? '' : '/')
        . 'reviews';
    my @page = `spin '$file'`;
    if ($? != 0) {
        die "$0: spin of $file failed with status ", ($? >> 8), "\n";
    }
    my ($title, $author);
    while (@page and $page[0] !~ /<table class=\"info\">/) {
        if ($page[0] =~ m{<h1><cite>(.*)</cite></h1>}) {
            $title = $1;
        } elsif ($page[0] =~ m{<p class="(?:author|date)">(.*)</p>}) {
            $author = $1;
        }
        shift @page;
    }
    die "$0: cannot find title and author in $file"
        unless ($title && $author);
    pop @page while (@page and $page[$#page] !~ /<p class=\"rating\">/);
    my $buy;
    for my $i (0 .. $#page) {
        if ($page[$i] =~ /<p class=\"buy\">/) {
            $buy = $i;
            last;
        }
    }
    splice (@page, $buy, 2) if $buy;
    my $page = join ('', @page);
    $page =~ s/^\s*<table[^>]+>/<table>/mg;
    $page =~ s/^\s*<tr/  <tr/mg;
    $page =~ s/^\s*<td[^>]+>/    <td>/mg;
    $page =~ s{</tr></table></div>}{</tr></table>};
    $page =~ s/<div class=\"review\">//;
    $page =~ s/<p class=\"rating\">/<p>/;
    $page =~ s{<span class="story"><span id="\S+">(.*?)</span></span>}
              {<strong>$1</strong>}sg;
    $page = "<p>Review: <cite>$title</cite>, $author</p>\n\n" . $page;
    return '<![CDATA[' . $page . "]]>\n";
}

# Print out the RSS version of the changes information given a file to which
# to print it, the file name, the metadata resulting RSS file, and a reference
# to the array of entries.  Various things are still hard-coded here.  Use the
# date of the last change as <pubDate> and the current time as
# <lastBuildDate>; it's not completely clear to me that this is correct.
sub rss_output {
    my ($file, $name, $metadata, $entries) = @_;
    $name =~ s,.*/,,;
    my $format = '%a, %d %b %Y %H:%M:%S %z';
    my $date = strftime ($format, localtime);
    my $last;
    if (@$entries) {
        $last = strftime ($format, localtime $entries->[0]{date});
    } else {
        $last = $date;
    }
    my $version = (split (' ', $ID))[2];
    print $file <<"EOC";
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>$metadata->{title}</title>
    <link>$metadata->{base}</link>
    <description>$metadata->{description}</description>
    <language>$metadata->{language}</language>
    <pubDate>$last</pubDate>
    <lastBuildDate>$date</lastBuildDate>
    <generator>spin-rss $version</generator>
EOC
    if ($metadata->{'rss-base'}) {
        print $file qq(    <atom:link href="$metadata->{'rss-base'}$file");
        print $file qq( rel="self"\n);
        print $file qq(               type="application/rss+xml" />\n);
    }
    print $file "\n";
    for my $entry (@$entries) {
        my $date = strftime ($format, localtime $entry->{date});
        my $title = xml_escape ($entry->{title});
        my $description;
        if ($entry->{description}) {
            $description = xml_escape ($entry->{description});
            $description =~ s/^/        /mg;
        } elsif ($entry->{journal}) {
            $description = rss_journal ($entry->{journal});
        } elsif ($entry->{review}) {
            $description = rss_review ($entry->{review}, $metadata);
        }
        $description =~ s{(<(?:a href|img src)=\")(?!http:)([./\w][^\"]+)\"}
                         {$1 . absolute_url ($2, $entry->{link}) . '"'}ge;
        my $perma = ($entry->{guid} =~ /^http/) ? '' : ' isPermaLink="false"';
        print $file "    <item>\n";
        print $file "      <title>$title</title>\n";
        print $file "      <link>$entry->{link}</link>\n";
        print $file "      <description>\n";
        print $file "$description";
        print $file "      </description>\n";
        print $file "      <pubDate>$date</pubDate>\n";
        print $file "      <guid$perma>$entry->{guid}</guid>\n";
        print $file "    </item>\n";
    }
    print $file "  </channel>\n";
    print $file "</rss>\n";
}

##############################################################################
# Thread output
##############################################################################

# Print out the thread version of the recent changes list, given a file to
# which to print it, the metadata, and a reference to the array of entries.
sub thread_output {
    my ($file, $metadata, $entries) = @_;
    if ($metadata->{'thread-prefix'}) {
        print $file $metadata->{'thread-prefix'}, "\n";
    } else {
        print $file "\\heading[Recent Changes][indent]\n\n";
        print $file "\\h1[Recent Changes]\n\n";
    }
    my $last;
    for my $entry (@$entries) {
        my $month = strftime ('%B %Y', localtime $entry->{date});
        if (not $last or $month ne $last) {
            print $file "\\h2[$month]\n\n";
            $last = $month;
        }
        my $date = strftime ('%Y-%m-%d', localtime $entry->{date});
        print $file "\\desc[$date \\entity[mdash]\n";
        print $file "      \\link[$entry->{link}]\n";
        print $file "           [$entry->{title}]][\n";
        my $description = $entry->{description};
        $description =~ s/^/    /mg;
        print $file $description;
        print $file "]\n\n";
    }
    print $file "\\signature\n";
}

##############################################################################
# Index output
##############################################################################

# Translate the thread of a journal entry for inclusion in an index page.
# Also takes the full URL for the permanent link to the entry page.  Returns
# the thread.
sub index_journal {
    my ($file, $url) = @_;
    open (IN, '<', $file) or die "$0: cannot open $file: $!\n";
    local $_;
    while (<IN>) {
        last if /\\h1/;
    }
    my $text = <IN>;
    $text = '' if $text =~ /^\s*$/;
    while (<IN>) {
        last if /^\\class\(date\)/;
        $text .= $_;
    }
    close IN;
    return $text;
}

# Translate the thread of a book review for inclusion into an index page.
# Also takes the full URL for the permanent link to the entry page.  Returns
# the thread.
sub index_review {
    my ($file, $url) = @_;
    open (IN, '<', $file) or die "$0: cannot open $file: $!\n";
    local $_;
    my ($title, $author);
    while (<IN>) {
        my $char = '(?:[^\]\\\\]|\\\\entity\[\S+\])';
        if (/\\(header|edited)\s*\[($char+)\]\s*$/) {
            $_ .= <IN>;
        }
        if (/\\(header|edited)\s*\[($char+)\]\s*\[($char+)\]/) {
            ($title, $author) = ($2, $3);
            $author .= ' (ed.)' if ($1 eq 'edited');
            last;
        }
    }
    unless (defined $author) {
        die "$0: cannot parse review file $file\n";
    }
    my $text;
    if ($file =~ m,/magazines/,) {
        $text = "Review: \\cite[$title], $author\n\n";
    } else {
        $text = "Review: \\cite[$title], by $author\n\n";
    }
    $text .= "\\table[][\n";
    while (<IN>) {
        last if /^\\div\(review\)\[/;
        my $char = '(?:[^\]\\\\]|\\\\entity\[\S+\])';
        if (/^\s*\\data\[($char+)\]\s*\[($char+)\]/) {
            $text .= "    \\tablerow[$1][$2]\n";
        }
    }
    $text .= "]\n\n";
    while (<IN>) {
        last if /^\\done/;
        s/\\story\[\d+\]/\\strong/g;
        s/^\\rating\s*\[([^\]]+)\]/Rating: $1 out of 10/;
        $text .= $_;
    }
    close IN;
    return $text;
}

# Print out the index version of the recent changes list, given a file to
# which to print it, the metadata, and a reference to the array of entries.
sub index_output {
    my ($file, $metadata, $entries) = @_;
    if ($metadata->{'index-prefix'}) {
        print $file $metadata->{'index-prefix'}, "\n";
    }
    my $last;
    for my $entry (@$entries) {
        my $date = strftime ('%Y-%m-%d %H:%M', localtime $entry->{date});
        my $day = $date;
        $day =~ s/ .*//;
        print $file "\\h2[$day: $entry->{title}]\n\n";
        my $text;
        if ($entry->{journal}) {
            $text = index_journal ($entry->{journal}, $entry->{link});
        } elsif ($entry->{review}) {
            $text = index_review ($entry->{review}, $entry->{link});
        }
        $text =~ s{(\\(?:link|image)\s*)\[([^\]]+)\]}
                  {"${1}[" . absolute_url ($2, $entry->{link}) . ']'}ge;
        $text =~ s{(\\image\s*)\[([^\]]+)\]}
            {"${1}[" . relative_url ($2, $metadata->{'index-base'}) . ']'}ge;
        print $file $text;
        print $file "\\class(footer)[$date \\entity[mdash]\n";
        print $file "    \\link[$entry->{link}]\n";
        print $file "         [Permanent link]]\n\n";
    }
    if ($metadata->{'index-suffix'}) {
        print $file $metadata->{'index-suffix'}, "\n";
    }
    print $file "\\signature\n";
}

##############################################################################
# Main routine
##############################################################################

$| = 1;
my $fullpath = $0;
$0 =~ s%.*/%%;

# Parse command-line options.
my ($base, $help, $version);
Getopt::Long::config ('bundling');
GetOptions ('b|base=s'  => \$base,
            'h|help'    => \$help,
            'v|version' => \$version) or exit 1;
if ($help) {
    print "Feeding myself to perldoc, please wait....\n";
    exec ('perldoc', '-t', $fullpath);
} elsif ($version) {
    my $version = join (' ', (split (' ', $ID))[1..3]);
    $version =~ s/,v\b//;
    $version =~ s/(\S+)$/($1)/;
    $version =~ tr%/%-%;
    print $version, "\n";
    exit;
}
$base =~ s,/*$,/, if $base;
my ($source) = @ARGV;
die "Usage: $0 [-hv] <source>\n" unless $source;

# Read in the changes.
my (%metadata, @changes);
parse_changes ($source, \%metadata, \@changes);

# Now, the output key tells us what files to write out.
my @output;
if ($metadata{output}) {
    @output = split (' ', $metadata{output});
} else {
    @output = ('*:rss:index.rss');
}
for my $output (@output) {
    my ($tags, $format, $file) = split (':', $output);
    $path = "$base$file" if ($base && $file !~ m,^/,);
    my $prettyfile = $path;
    $prettyfile = ".../$prettyfile" unless $prettyfile =~ m,^/,;
    next if (-f $path && -M $path <= -M $source);
    my @tags = split (',', $tags);
    my @interest;
    for my $change (@changes) {
        if ($tags eq '*' || intersect ($change->{tags}, \@tags)) {
            push (@interest, $change);
        }
    }
    if ($format eq 'thread') {
        print "Generating thread file $prettyfile\n";
        open (THREAD, '>', $path) or die "$0: cannot create $path: $!\n";
        thread_output (\*THREAD, \%metadata, \@interest);
        close THREAD;
    } elsif ($format eq 'rss') {
        if (@interest > 15) {
            splice (@interest, 15);
        }
        print "Generating RSS file $prettyfile\n";
        open (RSS, '>', $path) or die "$0: cannot create $path: $!\n";
        rss_output (\*RSS, $file, \%metadata, \@interest);
        close RSS;
    } elsif ($format eq 'index') {
        if (@interest > 15) {
            splice (@interest, 15);
        }
        print "Generating index file $prettyfile\n";
        open (INDEX, '>', $path) or die "$0: cannot create $path: $!\n";
        index_output (\*INDEX, \%metadata, \@interest);
        close INDEX;
    }
}
