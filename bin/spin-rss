#!/usr/bin/perl -w
our $ID = q$Id$;
#
# spin-changes -- Translate a changes file to RSS and thread.
#
# Copyright 2008 Russ Allbery <rra@stanford.edu>
#
# This program is free software; you may redistribute it and/or modify it
# under the same terms as Perl itself.

##############################################################################
# Modules and declarations
##############################################################################

require 5.006;

use strict;
use Date::Parse qw(str2time);
use Getopt::Long qw(GetOptions);
use POSIX qw(strftime);

##############################################################################
# Utility functions
##############################################################################

# Returns the intersection of two arrays as a list.
sub intersect {
    my ($a, $b) = @_;
    my %a = map { $_ => 1 } @$a;
    return grep { $a{$_} } @$b;
}

##############################################################################
# Parsing
##############################################################################

# Parse a change file.  Save the metadata into the provided hash reference and
# the changes into the provided array reference.  Each element of the array
# will be a hash with keys title, date, link, and description.
sub parse_changes {
    my ($file, $metadata, $changes) = @_;
    open (CHANGES, '<', $file) or die "$0: cannot open $file: $!\n";
    local $_;
    my ($last, @blocks);
    push (@blocks, {});
    my $current = $blocks[0];
    while (<CHANGES>) {
        if (/^\s*$/) {
            push (@blocks, {});
            $current = $blocks[$#blocks];
        } elsif (/^(\S+):[ \t]+(.*)/) {
            my ($key, $value) = ($1, $2);
            die "$0: cannot parse $file at line $.\n" unless $value;
            $value =~ s/\s+$//;
            $last = lc $key;
            $current->{$last} = $value;
        } elsif (/^(\S+):/) {
            $last = lc $1;
            $current->{$last} ||= '';
        } elsif (/^\s/) {
            my $value = $_;
            $value =~ s/^\s//;
            $value = "\n" if $value =~ /^\.\s*\n/;
            $current->{$last} .= $value;
        }
    }
    close CHANGES;
    %$metadata = %{ shift @blocks };
    my %guids;
    for my $block (@blocks) {
        $block->{date} = str2time ($block->{date})
            or die "$0: cannot parse date $block->{date}\n";
        if ($block->{link} && $block->{link} !~ /^http/) {
            $block->{link} = $metadata->{base} . $block->{link};
        }
        unless ($block->{guid}) {
            my $guid;
            if ($block->{journal} || $block->{review}) {
                $guid = $block->{link};
            } else {
                $guid = $block->{date};
            }
            die "$0: duplicate GUID for entry $guid\n" if $guids{$guid};
            $block->{guid} = $guid;
        }
        if ($block->{tags}) {
            $block->{tags} = [ split (' ', $block->{tags}) ];
        } else {
            $block->{tags} = [];
        }
        push (@{ $block->{tags} }, 'review') if $block->{review};
    }
    @$changes = @blocks;
}

##############################################################################
# RSS output
##############################################################################

# Escape a string for XML.
sub xml_escape {
    my ($string) = @_;
    $string =~ s/&/&amp;/g;
    $string =~ s/</&lt;/g;
    $string =~ s/>/&gt;/g;
    return $string;
}

# Format a journal post into HTML for inclusion in an RSS feed.
sub rss_journal {
    my ($file) = @_;
    my @page = `spin '$file'`;
    if ($? != 0) {
        die "$0: spin of $file failed with status ", ($? >> 8), "\n";
    }
    shift @page while (@page and $page[0] !~ /<h1>/);
    shift @page;
    shift @page while (@page and $page[0] =~ /^\s*$/);
    pop @page while (@page and $page[$#page] !~ /<p class=\"date\">/);
    pop @page;
    pop @page while (@page and $page[$#page] =~ /^\s*$/);
    return '<![CDATA[' . join ('', @page) . "]]>\n";
}

# Format a review into HTML for inclusion in an RSS feed.  Takes the path to
# the review thread file and the metadata for this feed.
sub rss_review {
    my ($file, $metadata) = @_;
    my $dir = $file;
    $dir =~ s%/+[^/]*$%%;
    my $class = ($dir =~ /magazines/) ? 'magazines' : 'books';
    my $base = $metadata->{base} . '/reviews';
    my @page = `spin '$file'`;
    if ($? != 0) {
        die "$0: spin of $file failed with status ", ($? >> 8), "\n";
    }
    shift @page while (@page and $page[0] !~ /<table class=\"info\">/);
    pop @page while (@page and $page[$#page] !~ /<p class=\"rating\">/);
    my $buy;
    for my $i (0 .. $#page) {
        if ($page[$i] =~ /<p class=\"buy\">/) {
            $buy = $i;
            last;
        }
    }
    splice (@page, $buy, 2) if $buy;
    my $page = join ('', @page);
    $page =~ s/^\s*<table[^>]+>/<table>/mg;
    $page =~ s/^\s*<tr/  <tr/mg;
    $page =~ s/^\s*<td[^>]+>/    <td>/mg;
    $page =~ s/<div class=\"review\">//;
    $page =~ s/<p class=\"rating\">/<p>/;
    $page =~ s{(href=\")(?!http:)(\w[^\"]+\")}
              {$1$base/$class/$2}g;
    $page =~ s{(href=\")\.\./(\w[^\"]+\")}
              {$1$base/$2}g;
    $page =~ s{<span class="story"><span id="\S+">(.*?)</span></span>}
              {<strong>$1</strong>}sg;
    return '<![CDATA[' . $page . "]]>\n";
}

# Print out the RSS version of the changes information given a file to which
# to print it, the metadata resulting RSS file, and a reference to the array
# of entries.  Various things are still hard-coded here.  Use the date of the
# last change as <pubDate> and the current time as <lastBuildDate>; it's not
# completely clear to me that this is correct.
sub rss_output {
    my ($file, $metadata, $entries) = @_;
    my $format = '%a, %d %b %Y %H:%M:%S %z';
    my $date = strftime ($format, localtime);
    my $last = strftime ($format, localtime $entries->[0]{date});
    my $version = (split (' ', $ID))[2];
    print $file <<"EOC";
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>$metadata->{title}</title>
    <link>$metadata->{base}</link>
    <description>$metadata->{description}</description>
    <language>$metadata->{language}</language>
    <pubDate>$last</pubDate>
    <lastBuildDate>$date</lastBuildDate>
    <generator>spin-changes $version</generator>
EOC
    if ($metadata->{rss}) {
        print $file qq(    <atom:link href="$metadata->{rss}" rel="self"\n);
        print $file qq(               type="application/rss+xml" />\n);
    }
    print $file "\n";
    for my $entry (@$entries) {
        my $date = strftime ($format, localtime $entry->{date});
        my $title = xml_escape ($entry->{title});
        my $description;
        if ($entry->{description}) {
            $description = xml_escape ($entry->{description});
            $description =~ s/^/        /mg;
        } elsif ($entry->{journal}) {
            $description = rss_journal ($entry->{journal});
        } elsif ($entry->{review}) {
            $description = rss_review ($entry->{review}, $metadata);
        }
        my $perma = ($entry->{guid} =~ /^http/) ? '' : ' isPermaLink="false"';
        print $file "    <item>\n";
        print $file "      <title>$title</title>\n";
        print $file "      <link>$entry->{link}</link>\n";
        print $file "      <description>\n";
        print $file "$description";
        print $file "      </description>\n";
        print $file "      <pubDate>$date</pubDate>\n";
        print $file "      <guid$perma>$entry->{guid}</guid>\n";
        print $file "    </item>\n";
    }
    print $file "  </channel>\n";
    print $file "</rss>\n";
}

##############################################################################
# Thread output
##############################################################################

# Print out the thread version of the recent changes list, given a file to
# which to print it and a reference to the array of entries.
sub thread_output {
    my ($file, $entries) = @_;
    print $file "\\heading[Recent Changes][indent]\n\n";
    print $file "\\h1[Recent Changes]\n\n";
    my $last;
    for my $entry (@$entries) {
        my $month = strftime ('%B %Y', localtime $entry->{date});
        if (not $last or $month ne $last) {
            print $file "\\h2[$month]\n\n";
            $last = $month;
        }
        my $date = strftime ('%Y-%m-%d', localtime $entry->{date});
        print $file "\\desc[$date \\entity[mdash]\n";
        print $file "      \\link[$entry->{link}]\n";
        print $file "           [$entry->{title}]][\n";
        my $description = $entry->{description};
        $description =~ s/^/    /mg;
        print $file $description;
        print $file "]\n\n";
    }
    print $file "\\signature\n";
}

##############################################################################
# Main routine
##############################################################################

$| = 1;
my $fullpath = $0;
$0 =~ s%.*/%%;

# Parse command-line options.
my ($base, $help, $version);
Getopt::Long::config ('bundling');
GetOptions ('b|base=s'  => \$base,
            'h|help'    => \$help,
            'v|version' => \$version) or exit 1;
if ($help) {
    print "Feeding myself to perldoc, please wait....\n";
    exec ('perldoc', '-t', $fullpath);
} elsif ($version) {
    my $version = join (' ', (split (' ', $ID))[1..3]);
    $version =~ s/,v\b//;
    $version =~ s/(\S+)$/($1)/;
    $version =~ tr%/%-%;
    print $version, "\n";
    exit;
}
$base =~ s,/*$,/, if $base;
my ($source) = @ARGV;
die "Usage: $0 [-hv] <source>\n" unless $source;

# Read in the changes.
my (%metadata, @changes);
parse_changes ($source, \%metadata, \@changes);

# Now, the output key tells us what files to write out.
my @output;
if ($metadata{output}) {
    @output = split (' ', $metadata{output});
} else {
    @output = ('*:rss:index.rss');
}
for my $output (@output) {
    my ($tags, $format, $file) = split (':', $output);
    $file = "$base$file" if ($base && $file !~ m,^/,);
    next if (-f $file && -M $file <= -M $source);
    my @tags = split (',', $tags);
    my @interest;
    for my $change (@changes) {
        if ($tags eq '*' || intersect ($change->{tags}, \@tags)) {
            push (@interest, $change);
        }
    }
    if ($format eq 'thread') {
        print "Generating thread file .../$file\n";
        open (THREAD, '>', $file) or die "$0: cannot create $file: $!\n";
        thread_output (\*THREAD, \@interest);
        close THREAD;
    } elsif ($format eq 'rss') {
        if (@interest > 15) {
            splice (@interest, 15);
        }
        print "Generating RSS file .../$file\n";
        open (RSS, '>', $file) or die "$0: cannot create $file: $!\n";
        rss_output (\*RSS, \%metadata, \@interest);
        close RSS;
    }
}
